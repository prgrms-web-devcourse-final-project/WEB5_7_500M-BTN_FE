/* tslint:disable */
/* eslint-disable */
/**
 * 맛잘알 API
 * 엑세스 토큰은 발급 후 헤더에 들어가고 리프래쉬 토큰은 HTTP ONLY 쿠키에 들어갑니다
 *
 * The version of the OpenAPI document: v1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AccessTokenResponseDto
 */
export interface AccessTokenResponseDto {
    /**
     * 
     * @type {string}
     * @memberof AccessTokenResponseDto
     */
    'accessToken'?: string;
}
/**
 * 
 * @export
 * @interface BaseResponseAccessTokenResponseDto
 */
export interface BaseResponseAccessTokenResponseDto {
    /**
     * 
     * @type {string}
     * @memberof BaseResponseAccessTokenResponseDto
     */
    'status'?: BaseResponseAccessTokenResponseDtoStatusEnum;
    /**
     * 
     * @type {AccessTokenResponseDto}
     * @memberof BaseResponseAccessTokenResponseDto
     */
    'data'?: AccessTokenResponseDto;
}

export const BaseResponseAccessTokenResponseDtoStatusEnum = {
    Ok: 'OK',
    Created: 'CREATED'
} as const;

export type BaseResponseAccessTokenResponseDtoStatusEnum = typeof BaseResponseAccessTokenResponseDtoStatusEnum[keyof typeof BaseResponseAccessTokenResponseDtoStatusEnum];

/**
 * 
 * @export
 * @interface BaseResponseListCommentResponse
 */
export interface BaseResponseListCommentResponse {
    /**
     * 
     * @type {string}
     * @memberof BaseResponseListCommentResponse
     */
    'status'?: BaseResponseListCommentResponseStatusEnum;
    /**
     * 
     * @type {Array<CommentResponse>}
     * @memberof BaseResponseListCommentResponse
     */
    'data'?: Array<CommentResponse>;
}

export const BaseResponseListCommentResponseStatusEnum = {
    Ok: 'OK',
    Created: 'CREATED'
} as const;

export type BaseResponseListCommentResponseStatusEnum = typeof BaseResponseListCommentResponseStatusEnum[keyof typeof BaseResponseListCommentResponseStatusEnum];

/**
 * 
 * @export
 * @interface BaseResponseMyInfoResponse
 */
export interface BaseResponseMyInfoResponse {
    /**
     * 
     * @type {string}
     * @memberof BaseResponseMyInfoResponse
     */
    'status'?: BaseResponseMyInfoResponseStatusEnum;
    /**
     * 
     * @type {MyInfoResponse}
     * @memberof BaseResponseMyInfoResponse
     */
    'data'?: MyInfoResponse;
}

export const BaseResponseMyInfoResponseStatusEnum = {
    Ok: 'OK',
    Created: 'CREATED'
} as const;

export type BaseResponseMyInfoResponseStatusEnum = typeof BaseResponseMyInfoResponseStatusEnum[keyof typeof BaseResponseMyInfoResponseStatusEnum];

/**
 * 
 * @export
 * @interface BaseResponseMyPartyPageResponse
 */
export interface BaseResponseMyPartyPageResponse {
    /**
     * 
     * @type {string}
     * @memberof BaseResponseMyPartyPageResponse
     */
    'status'?: BaseResponseMyPartyPageResponseStatusEnum;
    /**
     * 
     * @type {MyPartyPageResponse}
     * @memberof BaseResponseMyPartyPageResponse
     */
    'data'?: MyPartyPageResponse;
}

export const BaseResponseMyPartyPageResponseStatusEnum = {
    Ok: 'OK',
    Created: 'CREATED'
} as const;

export type BaseResponseMyPartyPageResponseStatusEnum = typeof BaseResponseMyPartyPageResponseStatusEnum[keyof typeof BaseResponseMyPartyPageResponseStatusEnum];

/**
 * 
 * @export
 * @interface BaseResponseMyReservationPageResponse
 */
export interface BaseResponseMyReservationPageResponse {
    /**
     * 
     * @type {string}
     * @memberof BaseResponseMyReservationPageResponse
     */
    'status'?: BaseResponseMyReservationPageResponseStatusEnum;
    /**
     * 
     * @type {MyReservationPageResponse}
     * @memberof BaseResponseMyReservationPageResponse
     */
    'data'?: MyReservationPageResponse;
}

export const BaseResponseMyReservationPageResponseStatusEnum = {
    Ok: 'OK',
    Created: 'CREATED'
} as const;

export type BaseResponseMyReservationPageResponseStatusEnum = typeof BaseResponseMyReservationPageResponseStatusEnum[keyof typeof BaseResponseMyReservationPageResponseStatusEnum];

/**
 * 
 * @export
 * @interface BaseResponseMyReviewPageResponse
 */
export interface BaseResponseMyReviewPageResponse {
    /**
     * 
     * @type {string}
     * @memberof BaseResponseMyReviewPageResponse
     */
    'status'?: BaseResponseMyReviewPageResponseStatusEnum;
    /**
     * 
     * @type {MyReviewPageResponse}
     * @memberof BaseResponseMyReviewPageResponse
     */
    'data'?: MyReviewPageResponse;
}

export const BaseResponseMyReviewPageResponseStatusEnum = {
    Ok: 'OK',
    Created: 'CREATED'
} as const;

export type BaseResponseMyReviewPageResponseStatusEnum = typeof BaseResponseMyReviewPageResponseStatusEnum[keyof typeof BaseResponseMyReviewPageResponseStatusEnum];

/**
 * 
 * @export
 * @interface BaseResponseOwnerShopsList
 */
export interface BaseResponseOwnerShopsList {
    /**
     * 
     * @type {string}
     * @memberof BaseResponseOwnerShopsList
     */
    'status'?: BaseResponseOwnerShopsListStatusEnum;
    /**
     * 
     * @type {OwnerShopsList}
     * @memberof BaseResponseOwnerShopsList
     */
    'data'?: OwnerShopsList;
}

export const BaseResponseOwnerShopsListStatusEnum = {
    Ok: 'OK',
    Created: 'CREATED'
} as const;

export type BaseResponseOwnerShopsListStatusEnum = typeof BaseResponseOwnerShopsListStatusEnum[keyof typeof BaseResponseOwnerShopsListStatusEnum];

/**
 * 
 * @export
 * @interface BaseResponsePartyDetailResponse
 */
export interface BaseResponsePartyDetailResponse {
    /**
     * 
     * @type {string}
     * @memberof BaseResponsePartyDetailResponse
     */
    'status'?: BaseResponsePartyDetailResponseStatusEnum;
    /**
     * 
     * @type {PartyDetailResponse}
     * @memberof BaseResponsePartyDetailResponse
     */
    'data'?: PartyDetailResponse;
}

export const BaseResponsePartyDetailResponseStatusEnum = {
    Ok: 'OK',
    Created: 'CREATED'
} as const;

export type BaseResponsePartyDetailResponseStatusEnum = typeof BaseResponsePartyDetailResponseStatusEnum[keyof typeof BaseResponsePartyDetailResponseStatusEnum];

/**
 * 
 * @export
 * @interface BaseResponsePartyScrollResponse
 */
export interface BaseResponsePartyScrollResponse {
    /**
     * 
     * @type {string}
     * @memberof BaseResponsePartyScrollResponse
     */
    'status'?: BaseResponsePartyScrollResponseStatusEnum;
    /**
     * 
     * @type {PartyScrollResponse}
     * @memberof BaseResponsePartyScrollResponse
     */
    'data'?: PartyScrollResponse;
}

export const BaseResponsePartyScrollResponseStatusEnum = {
    Ok: 'OK',
    Created: 'CREATED'
} as const;

export type BaseResponsePartyScrollResponseStatusEnum = typeof BaseResponsePartyScrollResponseStatusEnum[keyof typeof BaseResponsePartyScrollResponseStatusEnum];

/**
 * 
 * @export
 * @interface BaseResponsePaymentSuccessResponse
 */
export interface BaseResponsePaymentSuccessResponse {
    /**
     * 
     * @type {string}
     * @memberof BaseResponsePaymentSuccessResponse
     */
    'status'?: BaseResponsePaymentSuccessResponseStatusEnum;
    /**
     * 
     * @type {PaymentSuccessResponse}
     * @memberof BaseResponsePaymentSuccessResponse
     */
    'data'?: PaymentSuccessResponse;
}

export const BaseResponsePaymentSuccessResponseStatusEnum = {
    Ok: 'OK',
    Created: 'CREATED'
} as const;

export type BaseResponsePaymentSuccessResponseStatusEnum = typeof BaseResponsePaymentSuccessResponseStatusEnum[keyof typeof BaseResponsePaymentSuccessResponseStatusEnum];

/**
 * 
 * @export
 * @interface BaseResponsePreSignedUrlListResponse
 */
export interface BaseResponsePreSignedUrlListResponse {
    /**
     * 
     * @type {string}
     * @memberof BaseResponsePreSignedUrlListResponse
     */
    'status'?: BaseResponsePreSignedUrlListResponseStatusEnum;
    /**
     * 
     * @type {PreSignedUrlListResponse}
     * @memberof BaseResponsePreSignedUrlListResponse
     */
    'data'?: PreSignedUrlListResponse;
}

export const BaseResponsePreSignedUrlListResponseStatusEnum = {
    Ok: 'OK',
    Created: 'CREATED'
} as const;

export type BaseResponsePreSignedUrlListResponseStatusEnum = typeof BaseResponsePreSignedUrlListResponseStatusEnum[keyof typeof BaseResponsePreSignedUrlListResponseStatusEnum];

/**
 * 
 * @export
 * @interface BaseResponsePreSignedUrlResponse
 */
export interface BaseResponsePreSignedUrlResponse {
    /**
     * 
     * @type {string}
     * @memberof BaseResponsePreSignedUrlResponse
     */
    'status'?: BaseResponsePreSignedUrlResponseStatusEnum;
    /**
     * 
     * @type {PreSignedUrlResponse}
     * @memberof BaseResponsePreSignedUrlResponse
     */
    'data'?: PreSignedUrlResponse;
}

export const BaseResponsePreSignedUrlResponseStatusEnum = {
    Ok: 'OK',
    Created: 'CREATED'
} as const;

export type BaseResponsePreSignedUrlResponseStatusEnum = typeof BaseResponsePreSignedUrlResponseStatusEnum[keyof typeof BaseResponsePreSignedUrlResponseStatusEnum];

/**
 * 
 * @export
 * @interface BaseResponseReservationListResponse
 */
export interface BaseResponseReservationListResponse {
    /**
     * 
     * @type {string}
     * @memberof BaseResponseReservationListResponse
     */
    'status'?: BaseResponseReservationListResponseStatusEnum;
    /**
     * 
     * @type {ReservationListResponse}
     * @memberof BaseResponseReservationListResponse
     */
    'data'?: ReservationListResponse;
}

export const BaseResponseReservationListResponseStatusEnum = {
    Ok: 'OK',
    Created: 'CREATED'
} as const;

export type BaseResponseReservationListResponseStatusEnum = typeof BaseResponseReservationListResponseStatusEnum[keyof typeof BaseResponseReservationListResponseStatusEnum];

/**
 * 
 * @export
 * @interface BaseResponseReviewPageResponse
 */
export interface BaseResponseReviewPageResponse {
    /**
     * 
     * @type {string}
     * @memberof BaseResponseReviewPageResponse
     */
    'status'?: BaseResponseReviewPageResponseStatusEnum;
    /**
     * 
     * @type {ReviewPageResponse}
     * @memberof BaseResponseReviewPageResponse
     */
    'data'?: ReviewPageResponse;
}

export const BaseResponseReviewPageResponseStatusEnum = {
    Ok: 'OK',
    Created: 'CREATED'
} as const;

export type BaseResponseReviewPageResponseStatusEnum = typeof BaseResponseReviewPageResponseStatusEnum[keyof typeof BaseResponseReviewPageResponseStatusEnum];

/**
 * 
 * @export
 * @interface BaseResponseShopDetailResponse
 */
export interface BaseResponseShopDetailResponse {
    /**
     * 
     * @type {string}
     * @memberof BaseResponseShopDetailResponse
     */
    'status'?: BaseResponseShopDetailResponseStatusEnum;
    /**
     * 
     * @type {ShopDetailResponse}
     * @memberof BaseResponseShopDetailResponse
     */
    'data'?: ShopDetailResponse;
}

export const BaseResponseShopDetailResponseStatusEnum = {
    Ok: 'OK',
    Created: 'CREATED'
} as const;

export type BaseResponseShopDetailResponseStatusEnum = typeof BaseResponseShopDetailResponseStatusEnum[keyof typeof BaseResponseShopDetailResponseStatusEnum];

/**
 * 
 * @export
 * @interface BaseResponseShopOwnerDetailResponse
 */
export interface BaseResponseShopOwnerDetailResponse {
    /**
     * 
     * @type {string}
     * @memberof BaseResponseShopOwnerDetailResponse
     */
    'status'?: BaseResponseShopOwnerDetailResponseStatusEnum;
    /**
     * 
     * @type {ShopOwnerDetailResponse}
     * @memberof BaseResponseShopOwnerDetailResponse
     */
    'data'?: ShopOwnerDetailResponse;
}

export const BaseResponseShopOwnerDetailResponseStatusEnum = {
    Ok: 'OK',
    Created: 'CREATED'
} as const;

export type BaseResponseShopOwnerDetailResponseStatusEnum = typeof BaseResponseShopOwnerDetailResponseStatusEnum[keyof typeof BaseResponseShopOwnerDetailResponseStatusEnum];

/**
 * 
 * @export
 * @interface BaseResponseShopPageResponse
 */
export interface BaseResponseShopPageResponse {
    /**
     * 
     * @type {string}
     * @memberof BaseResponseShopPageResponse
     */
    'status'?: BaseResponseShopPageResponseStatusEnum;
    /**
     * 
     * @type {ShopPageResponse}
     * @memberof BaseResponseShopPageResponse
     */
    'data'?: ShopPageResponse;
}

export const BaseResponseShopPageResponseStatusEnum = {
    Ok: 'OK',
    Created: 'CREATED'
} as const;

export type BaseResponseShopPageResponseStatusEnum = typeof BaseResponseShopPageResponseStatusEnum[keyof typeof BaseResponseShopPageResponseStatusEnum];

/**
 * 
 * @export
 * @interface BaseResponseShopsResponse
 */
export interface BaseResponseShopsResponse {
    /**
     * 
     * @type {string}
     * @memberof BaseResponseShopsResponse
     */
    'status'?: BaseResponseShopsResponseStatusEnum;
    /**
     * 
     * @type {ShopsResponse}
     * @memberof BaseResponseShopsResponse
     */
    'data'?: ShopsResponse;
}

export const BaseResponseShopsResponseStatusEnum = {
    Ok: 'OK',
    Created: 'CREATED'
} as const;

export type BaseResponseShopsResponseStatusEnum = typeof BaseResponseShopsResponseStatusEnum[keyof typeof BaseResponseShopsResponseStatusEnum];

/**
 * 
 * @export
 * @interface BaseResponseVoid
 */
export interface BaseResponseVoid {
    /**
     * 
     * @type {string}
     * @memberof BaseResponseVoid
     */
    'status'?: BaseResponseVoidStatusEnum;
    /**
     * 
     * @type {object}
     * @memberof BaseResponseVoid
     */
    'data'?: object;
}

export const BaseResponseVoidStatusEnum = {
    Ok: 'OK',
    Created: 'CREATED'
} as const;

export type BaseResponseVoidStatusEnum = typeof BaseResponseVoidStatusEnum[keyof typeof BaseResponseVoidStatusEnum];

/**
 * 
 * @export
 * @interface CommentCreateRequest
 */
export interface CommentCreateRequest {
    /**
     * 부모 댓글 ID (대댓글인 경우)
     * @type {number}
     * @memberof CommentCreateRequest
     */
    'parentId'?: number;
    /**
     * 댓글 내용
     * @type {string}
     * @memberof CommentCreateRequest
     */
    'content': string;
}
/**
 * 
 * @export
 * @interface CommentResponse
 */
export interface CommentResponse {
    /**
     * 
     * @type {number}
     * @memberof CommentResponse
     */
    'commentId'?: number;
    /**
     * 
     * @type {number}
     * @memberof CommentResponse
     */
    'parentId'?: number;
    /**
     * 
     * @type {string}
     * @memberof CommentResponse
     */
    'content'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommentResponse
     */
    'createdAt'?: string;
    /**
     * 
     * @type {Writer}
     * @memberof CommentResponse
     */
    'writer'?: Writer;
}
/**
 * 예약 생성 요청 DTO
 * @export
 * @interface CreateReservationRequest
 */
export interface CreateReservationRequest {
    /**
     * 예약 날짜 (yyyy-MM-dd 형식)
     * @type {string}
     * @memberof CreateReservationRequest
     */
    'date': string;
    /**
     * 예약 시간 (HH:mm 형식)
     * @type {string}
     * @memberof CreateReservationRequest
     */
    'time': string;
    /**
     * 예약 인원 수
     * @type {number}
     * @memberof CreateReservationRequest
     */
    'headCount'?: number;
    /**
     * 예약금 (최소 1000원)
     * @type {number}
     * @memberof CreateReservationRequest
     */
    'reservationFee'?: number;
}
/**
 * 예약 생성 응답 DTO
 * @export
 * @interface CreateReservationResponse
 */
export interface CreateReservationResponse {
    /**
     * 예약 ID
     * @type {number}
     * @memberof CreateReservationResponse
     */
    'reservationId'?: number;
    /**
     * 식당 이름
     * @type {string}
     * @memberof CreateReservationResponse
     */
    'shopName'?: string;
    /**
     * 예약 일시 (yyyy-MM-dd HH:mm)
     * @type {string}
     * @memberof CreateReservationResponse
     */
    'dateTime'?: string;
    /**
     * 예약 인원 수
     * @type {number}
     * @memberof CreateReservationResponse
     */
    'headCount'?: number;
    /**
     * 예약 상태
     * @type {string}
     * @memberof CreateReservationResponse
     */
    'status'?: CreateReservationResponseStatusEnum;
}

export const CreateReservationResponseStatusEnum = {
    Pending: 'PENDING',
    Cancelled: 'CANCELLED',
    Confirmed: 'CONFIRMED',
    Refused: 'REFUSED',
    Terminated: 'TERMINATED'
} as const;

export type CreateReservationResponseStatusEnum = typeof CreateReservationResponseStatusEnum[keyof typeof CreateReservationResponseStatusEnum];

/**
 * 
 * @export
 * @interface DeleteProfileRequest
 */
export interface DeleteProfileRequest {
    /**
     * 
     * @type {string}
     * @memberof DeleteProfileRequest
     */
    'profileKey': string;
}
/**
 * 영업 종료 시간
 * @export
 * @interface LocalTime
 */
export interface LocalTime {
    /**
     * 
     * @type {number}
     * @memberof LocalTime
     */
    'hour'?: number;
    /**
     * 
     * @type {number}
     * @memberof LocalTime
     */
    'minute'?: number;
    /**
     * 
     * @type {number}
     * @memberof LocalTime
     */
    'second'?: number;
    /**
     * 
     * @type {number}
     * @memberof LocalTime
     */
    'nano'?: number;
}
/**
 * 
 * @export
 * @interface LoginRequest
 */
export interface LoginRequest {
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface MyInfoResponse
 */
export interface MyInfoResponse {
    /**
     * 
     * @type {number}
     * @memberof MyInfoResponse
     */
    'userId'?: number;
    /**
     * 
     * @type {string}
     * @memberof MyInfoResponse
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof MyInfoResponse
     */
    'nickname'?: string;
    /**
     * 
     * @type {string}
     * @memberof MyInfoResponse
     */
    'role'?: MyInfoResponseRoleEnum;
    /**
     * 
     * @type {string}
     * @memberof MyInfoResponse
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof MyInfoResponse
     */
    'age'?: number;
    /**
     * 성별: M or W
     * @type {string}
     * @memberof MyInfoResponse
     */
    'gender'?: MyInfoResponseGenderEnum;
    /**
     * 
     * @type {number}
     * @memberof MyInfoResponse
     */
    'point'?: number;
    /**
     * 
     * @type {string}
     * @memberof MyInfoResponse
     */
    'phoneNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof MyInfoResponse
     */
    'profile'?: string;
}

export const MyInfoResponseRoleEnum = {
    Admin: 'ADMIN',
    User: 'USER',
    Owner: 'OWNER',
    Tmp: 'TMP'
} as const;

export type MyInfoResponseRoleEnum = typeof MyInfoResponseRoleEnum[keyof typeof MyInfoResponseRoleEnum];
export const MyInfoResponseGenderEnum = {
    M: 'M',
    W: 'W'
} as const;

export type MyInfoResponseGenderEnum = typeof MyInfoResponseGenderEnum[keyof typeof MyInfoResponseGenderEnum];

/**
 * 내 정보 수정 요청
 * @export
 * @interface MyInfoUpdateRequest
 */
export interface MyInfoUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof MyInfoUpdateRequest
     */
    'nickname': string;
    /**
     * 
     * @type {string}
     * @memberof MyInfoUpdateRequest
     */
    'phoneNumber': string;
    /**
     * 
     * @type {number}
     * @memberof MyInfoUpdateRequest
     */
    'age'?: number;
    /**
     * 
     * @type {string}
     * @memberof MyInfoUpdateRequest
     */
    'profileKey': string;
}
/**
 * 내 파티 목록 응답
 * @export
 * @interface MyPartyPageResponse
 */
export interface MyPartyPageResponse {
    /**
     * 파티 목록
     * @type {Array<MyPartyResponse>}
     * @memberof MyPartyPageResponse
     */
    'content'?: Array<MyPartyResponse>;
    /**
     * 다음 커서 ID
     * @type {number}
     * @memberof MyPartyPageResponse
     */
    'nextCursor'?: number;
}
/**
 * 파티 정보 요약
 * @export
 * @interface MyPartyResponse
 */
export interface MyPartyResponse {
    /**
     * 파티 ID
     * @type {number}
     * @memberof MyPartyResponse
     */
    'partyId'?: number;
    /**
     * 파티 제목
     * @type {string}
     * @memberof MyPartyResponse
     */
    'title'?: string;
    /**
     * 가게 이름
     * @type {string}
     * @memberof MyPartyResponse
     */
    'shopName'?: string;
    /**
     * 만남 일시
     * @type {string}
     * @memberof MyPartyResponse
     */
    'metAt'?: string;
    /**
     * 모집 마감 시간
     * @type {string}
     * @memberof MyPartyResponse
     */
    'deadline'?: string;
    /**
     * 파티 상태
     * @type {string}
     * @memberof MyPartyResponse
     */
    'status'?: MyPartyResponseStatusEnum;
    /**
     * 최대 인원
     * @type {number}
     * @memberof MyPartyResponse
     */
    'maxCount'?: number;
    /**
     * 최소 인원
     * @type {number}
     * @memberof MyPartyResponse
     */
    'minCount'?: number;
    /**
     * 현재 인원
     * @type {number}
     * @memberof MyPartyResponse
     */
    'currentCount'?: number;
    /**
     * 성별 조건
     * @type {string}
     * @memberof MyPartyResponse
     */
    'genderCondition'?: MyPartyResponseGenderConditionEnum;
    /**
     * 최소 나이
     * @type {number}
     * @memberof MyPartyResponse
     */
    'minAge'?: number;
    /**
     * 최대 나이
     * @type {number}
     * @memberof MyPartyResponse
     */
    'maxAge'?: number;
    /**
     * 설명
     * @type {string}
     * @memberof MyPartyResponse
     */
    'description'?: string;
}

export const MyPartyResponseStatusEnum = {
    Recruiting: 'RECRUITING',
    Completed: 'COMPLETED',
    Terminated: 'TERMINATED'
} as const;

export type MyPartyResponseStatusEnum = typeof MyPartyResponseStatusEnum[keyof typeof MyPartyResponseStatusEnum];
export const MyPartyResponseGenderConditionEnum = {
    M: 'M',
    W: 'W',
    A: 'A'
} as const;

export type MyPartyResponseGenderConditionEnum = typeof MyPartyResponseGenderConditionEnum[keyof typeof MyPartyResponseGenderConditionEnum];

/**
 * 내 예약 목록 응답
 * @export
 * @interface MyReservationPageResponse
 */
export interface MyReservationPageResponse {
    /**
     * 예약 목록
     * @type {Array<MyReservationResponse>}
     * @memberof MyReservationPageResponse
     */
    'content'?: Array<MyReservationResponse>;
    /**
     * 다음 커서 ID
     * @type {number}
     * @memberof MyReservationPageResponse
     */
    'nextCursor'?: number;
}
/**
 * 예약 정보 요약
 * @export
 * @interface MyReservationResponse
 */
export interface MyReservationResponse {
    /**
     * 예약 ID
     * @type {number}
     * @memberof MyReservationResponse
     */
    'reservationId'?: number;
    /**
     * 가게 이름
     * @type {string}
     * @memberof MyReservationResponse
     */
    'shopName'?: string;
    /**
     * 예약자 이름
     * @type {string}
     * @memberof MyReservationResponse
     */
    'name'?: string;
    /**
     * 예약 일시
     * @type {string}
     * @memberof MyReservationResponse
     */
    'reservedAt'?: string;
    /**
     * 예약 인원
     * @type {number}
     * @memberof MyReservationResponse
     */
    'headCount'?: number;
    /**
     * 예약금
     * @type {number}
     * @memberof MyReservationResponse
     */
    'reservationFee'?: number;
    /**
     * 예약 상태
     * @type {string}
     * @memberof MyReservationResponse
     */
    'status'?: MyReservationResponseStatusEnum;
}

export const MyReservationResponseStatusEnum = {
    Pending: 'PENDING',
    Cancelled: 'CANCELLED',
    Confirmed: 'CONFIRMED',
    Refused: 'REFUSED',
    Terminated: 'TERMINATED'
} as const;

export type MyReservationResponseStatusEnum = typeof MyReservationResponseStatusEnum[keyof typeof MyReservationResponseStatusEnum];

/**
 * 내 리뷰 목록 응답
 * @export
 * @interface MyReviewPageResponse
 */
export interface MyReviewPageResponse {
    /**
     * 리뷰 목록
     * @type {Array<MyReviewResponse>}
     * @memberof MyReviewPageResponse
     */
    'content'?: Array<MyReviewResponse>;
    /**
     * 다음 커서 ID
     * @type {number}
     * @memberof MyReviewPageResponse
     */
    'nextCursor'?: number;
}
/**
 * 리뷰 정보 요약
 * @export
 * @interface MyReviewResponse
 */
export interface MyReviewResponse {
    /**
     * 리뷰 ID
     * @type {number}
     * @memberof MyReviewResponse
     */
    'reviewId'?: number;
    /**
     * 가게 이름
     * @type {string}
     * @memberof MyReviewResponse
     */
    'shopName'?: string;
    /**
     * 평점
     * @type {number}
     * @memberof MyReviewResponse
     */
    'rating'?: number;
    /**
     * 리뷰 내용
     * @type {string}
     * @memberof MyReviewResponse
     */
    'content'?: string;
    /**
     * 작성일
     * @type {string}
     * @memberof MyReviewResponse
     */
    'createdAt'?: string;
    /**
     * 리뷰 이미지 목록
     * @type {Array<string>}
     * @memberof MyReviewResponse
     */
    'images'?: Array<string>;
}
/**
 * 
 * @export
 * @interface OAuthSignUpRequest
 */
export interface OAuthSignUpRequest {
    /**
     * 
     * @type {string}
     * @memberof OAuthSignUpRequest
     */
    'nickname': string;
    /**
     * 
     * @type {string}
     * @memberof OAuthSignUpRequest
     */
    'phoneNumber': string;
    /**
     * 
     * @type {string}
     * @memberof OAuthSignUpRequest
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof OAuthSignUpRequest
     */
    'age'?: number;
    /**
     * 
     * @type {string}
     * @memberof OAuthSignUpRequest
     */
    'gender': OAuthSignUpRequestGenderEnum;
}

export const OAuthSignUpRequestGenderEnum = {
    M: 'M',
    W: 'W'
} as const;

export type OAuthSignUpRequestGenderEnum = typeof OAuthSignUpRequestGenderEnum[keyof typeof OAuthSignUpRequestGenderEnum];

/**
 * 
 * @export
 * @interface OwnerShopItem
 */
export interface OwnerShopItem {
    /**
     * 
     * @type {number}
     * @memberof OwnerShopItem
     */
    'shopId'?: number;
    /**
     * 
     * @type {string}
     * @memberof OwnerShopItem
     */
    'shopName'?: string;
    /**
     * 
     * @type {string}
     * @memberof OwnerShopItem
     */
    'category'?: OwnerShopItemCategoryEnum;
    /**
     * 
     * @type {string}
     * @memberof OwnerShopItem
     */
    'roadAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof OwnerShopItem
     */
    'detailAddress'?: string;
    /**
     * 
     * @type {number}
     * @memberof OwnerShopItem
     */
    'rating'?: number;
    /**
     * 
     * @type {string}
     * @memberof OwnerShopItem
     */
    'thumbnailUrl'?: string;
}

export const OwnerShopItemCategoryEnum = {
    Chicken: 'CHICKEN',
    Chinese: 'CHINESE',
    Japanese: 'JAPANESE',
    Pizza: 'PIZZA',
    Fastfood: 'FASTFOOD',
    StewSoup: 'STEW_SOUP',
    JokBo: 'JOK_BO',
    Korean: 'KOREAN',
    Snack: 'SNACK',
    Western: 'WESTERN',
    Dessert: 'DESSERT'
} as const;

export type OwnerShopItemCategoryEnum = typeof OwnerShopItemCategoryEnum[keyof typeof OwnerShopItemCategoryEnum];

/**
 * 
 * @export
 * @interface OwnerShopsList
 */
export interface OwnerShopsList {
    /**
     * 
     * @type {Array<OwnerShopItem>}
     * @memberof OwnerShopsList
     */
    'shopItem'?: Array<OwnerShopItem>;
}
/**
 * 
 * @export
 * @interface PartyCreateRequest
 */
export interface PartyCreateRequest {
    /**
     * 게시글 제목
     * @type {string}
     * @memberof PartyCreateRequest
     */
    'title': string;
    /**
     * 음식점 ID
     * @type {number}
     * @memberof PartyCreateRequest
     */
    'shopId': number;
    /**
     * 모임 일시
     * @type {string}
     * @memberof PartyCreateRequest
     */
    'metAt': string;
    /**
     * 파티 모집 마감 일시
     * @type {string}
     * @memberof PartyCreateRequest
     */
    'deadline': string;
    /**
     * 모집 성별(W(여자), M(남자), A(무관) 중 택 1
     * @type {string}
     * @memberof PartyCreateRequest
     */
    'genderCondition': PartyCreateRequestGenderConditionEnum;
    /**
     * 모집 최소 나이
     * @type {number}
     * @memberof PartyCreateRequest
     */
    'minAge'?: number;
    /**
     * 모집 최대 나이
     * @type {number}
     * @memberof PartyCreateRequest
     */
    'maxAge'?: number;
    /**
     * 파티 최소 인원(파티 호스트 포함)
     * @type {number}
     * @memberof PartyCreateRequest
     */
    'minCount': number;
    /**
     * 파티 최대 인원(파티 호스트 포함)
     * @type {number}
     * @memberof PartyCreateRequest
     */
    'maxCount': number;
    /**
     * 게시글 본문
     * @type {string}
     * @memberof PartyCreateRequest
     */
    'description'?: string;
}

export const PartyCreateRequestGenderConditionEnum = {
    M: 'M',
    W: 'W',
    A: 'A'
} as const;

export type PartyCreateRequestGenderConditionEnum = typeof PartyCreateRequestGenderConditionEnum[keyof typeof PartyCreateRequestGenderConditionEnum];

/**
 * 
 * @export
 * @interface PartyDetailResponse
 */
export interface PartyDetailResponse {
    /**
     * 
     * @type {number}
     * @memberof PartyDetailResponse
     */
    'partyId'?: number;
    /**
     * 
     * @type {string}
     * @memberof PartyDetailResponse
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartyDetailResponse
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartyDetailResponse
     */
    'status'?: PartyDetailResponseStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof PartyDetailResponse
     */
    'maxCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof PartyDetailResponse
     */
    'minCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof PartyDetailResponse
     */
    'currentCount'?: number;
    /**
     * 
     * @type {string}
     * @memberof PartyDetailResponse
     */
    'genderCondition'?: PartyDetailResponseGenderConditionEnum;
    /**
     * 
     * @type {number}
     * @memberof PartyDetailResponse
     */
    'minAge'?: number;
    /**
     * 
     * @type {number}
     * @memberof PartyDetailResponse
     */
    'maxAge'?: number;
    /**
     * 
     * @type {string}
     * @memberof PartyDetailResponse
     */
    'metAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartyDetailResponse
     */
    'deadline'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartyDetailResponse
     */
    'createdAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof PartyDetailResponse
     */
    'hostId'?: number;
    /**
     * 
     * @type {number}
     * @memberof PartyDetailResponse
     */
    'shopId'?: number;
    /**
     * 
     * @type {string}
     * @memberof PartyDetailResponse
     */
    'shopName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartyDetailResponse
     */
    'shopRoadAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartyDetailResponse
     */
    'shopDetailAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartyDetailResponse
     */
    'shopImage'?: string;
}

export const PartyDetailResponseStatusEnum = {
    Recruiting: 'RECRUITING',
    Completed: 'COMPLETED',
    Terminated: 'TERMINATED'
} as const;

export type PartyDetailResponseStatusEnum = typeof PartyDetailResponseStatusEnum[keyof typeof PartyDetailResponseStatusEnum];
export const PartyDetailResponseGenderConditionEnum = {
    M: 'M',
    W: 'W',
    A: 'A'
} as const;

export type PartyDetailResponseGenderConditionEnum = typeof PartyDetailResponseGenderConditionEnum[keyof typeof PartyDetailResponseGenderConditionEnum];

/**
 * 
 * @export
 * @interface PartyListResponse
 */
export interface PartyListResponse {
    /**
     * 
     * @type {number}
     * @memberof PartyListResponse
     */
    'partyId'?: number;
    /**
     * 
     * @type {string}
     * @memberof PartyListResponse
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartyListResponse
     */
    'status'?: PartyListResponseStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof PartyListResponse
     */
    'maxCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof PartyListResponse
     */
    'minCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof PartyListResponse
     */
    'currentCount'?: number;
    /**
     * 
     * @type {string}
     * @memberof PartyListResponse
     */
    'metAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartyListResponse
     */
    'shopName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartyListResponse
     */
    'shopRoadAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartyListResponse
     */
    'shopDetailAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartyListResponse
     */
    'shopImage'?: string;
}

export const PartyListResponseStatusEnum = {
    Recruiting: 'RECRUITING',
    Completed: 'COMPLETED',
    Terminated: 'TERMINATED'
} as const;

export type PartyListResponseStatusEnum = typeof PartyListResponseStatusEnum[keyof typeof PartyListResponseStatusEnum];

/**
 * 
 * @export
 * @interface PartyScrollResponse
 */
export interface PartyScrollResponse {
    /**
     * 
     * @type {Array<PartyListResponse>}
     * @memberof PartyScrollResponse
     */
    'content'?: Array<PartyListResponse>;
    /**
     * 
     * @type {number}
     * @memberof PartyScrollResponse
     */
    'nextCursor'?: number;
}
/**
 * 
 * @export
 * @interface PaymentSuccessResponse
 */
export interface PaymentSuccessResponse {
    /**
     * 
     * @type {string}
     * @memberof PaymentSuccessResponse
     */
    'orderId'?: string;
    /**
     * 
     * @type {number}
     * @memberof PaymentSuccessResponse
     */
    'amount'?: number;
}
/**
 * 
 * @export
 * @interface PreSignedUrlListResponse
 */
export interface PreSignedUrlListResponse {
    /**
     * 
     * @type {Array<PreSignedUrlResponse>}
     * @memberof PreSignedUrlListResponse
     */
    'items'?: Array<PreSignedUrlResponse>;
    /**
     * 
     * @type {number}
     * @memberof PreSignedUrlListResponse
     */
    'refId'?: number;
}
/**
 * 
 * @export
 * @interface PreSignedUrlResponse
 */
export interface PreSignedUrlResponse {
    /**
     * 
     * @type {string}
     * @memberof PreSignedUrlResponse
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof PreSignedUrlResponse
     */
    'url'?: string;
}
/**
 * 예약 요약 정보 DTO
 * @export
 * @interface ReservationContent
 */
export interface ReservationContent {
    /**
     * 예약 ID
     * @type {number}
     * @memberof ReservationContent
     */
    'reservationId'?: number;
    /**
     * 식당 이름
     * @type {string}
     * @memberof ReservationContent
     */
    'shopName'?: string;
    /**
     * 예약 일시 (yyyy-MM-dd HH:mm)
     * @type {string}
     * @memberof ReservationContent
     */
    'reservedAt'?: string;
    /**
     * 예약 인원 수
     * @type {number}
     * @memberof ReservationContent
     */
    'headCount'?: number;
    /**
     * 예약자 전화번호
     * @type {string}
     * @memberof ReservationContent
     */
    'phoneNumber'?: string;
    /**
     * 예약상태
     * @type {string}
     * @memberof ReservationContent
     */
    'status'?: ReservationContentStatusEnum;
}

export const ReservationContentStatusEnum = {
    Pending: 'PENDING',
    Cancelled: 'CANCELLED',
    Confirmed: 'CONFIRMED',
    Refused: 'REFUSED',
    Terminated: 'TERMINATED'
} as const;

export type ReservationContentStatusEnum = typeof ReservationContentStatusEnum[keyof typeof ReservationContentStatusEnum];

/**
 * 예약 목록 응답 DTO
 * @export
 * @interface ReservationListResponse
 */
export interface ReservationListResponse {
    /**
     * 예약 요약 정보 리스트
     * @type {Array<ReservationContent>}
     * @memberof ReservationListResponse
     */
    'content'?: Array<ReservationContent>;
    /**
     * 다음 페이지 커서. 더 이상 없으면 null
     * @type {number}
     * @memberof ReservationListResponse
     */
    'nextCursor'?: number;
}
/**
 * 
 * @export
 * @interface ReviewCreateRequest
 */
export interface ReviewCreateRequest {
    /**
     * 예약 ID
     * @type {number}
     * @memberof ReviewCreateRequest
     */
    'reservationId': number;
    /**
     * 음식점 ID
     * @type {number}
     * @memberof ReviewCreateRequest
     */
    'shopId': number;
    /**
     * 리뷰 내용
     * @type {string}
     * @memberof ReviewCreateRequest
     */
    'content': string;
    /**
     * 별점(0.5~5.0)
     * @type {number}
     * @memberof ReviewCreateRequest
     */
    'rating': number;
    /**
     * 리뷰 이미지 목록
     * @type {number}
     * @memberof ReviewCreateRequest
     */
    'imageCount'?: number;
}
/**
 * 
 * @export
 * @interface ReviewPageResponse
 */
export interface ReviewPageResponse {
    /**
     * 
     * @type {number}
     * @memberof ReviewPageResponse
     */
    'nextCursor'?: number;
    /**
     * 
     * @type {Array<ReviewResponse>}
     * @memberof ReviewPageResponse
     */
    'content'?: Array<ReviewResponse>;
}
/**
 * 
 * @export
 * @interface ReviewResponse
 */
export interface ReviewResponse {
    /**
     * 
     * @type {number}
     * @memberof ReviewResponse
     */
    'reviewId'?: number;
    /**
     * 
     * @type {string}
     * @memberof ReviewResponse
     */
    'userNickname'?: string;
    /**
     * 
     * @type {number}
     * @memberof ReviewResponse
     */
    'rating'?: number;
    /**
     * 
     * @type {string}
     * @memberof ReviewResponse
     */
    'content'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReviewResponse
     */
    'createdAt'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ReviewResponse
     */
    'images'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ShopCreateRequest
 */
export interface ShopCreateRequest {
    /**
     * 상점 이름
     * @type {string}
     * @memberof ShopCreateRequest
     */
    'shopName': string;
    /**
     * 도로명 주소
     * @type {string}
     * @memberof ShopCreateRequest
     */
    'roadAddress': string;
    /**
     * 상세 주소
     * @type {string}
     * @memberof ShopCreateRequest
     */
    'detailAddress': string;
    /**
     * 시/도
     * @type {string}
     * @memberof ShopCreateRequest
     */
    'sido': string;
    /**
     * 위도
     * @type {number}
     * @memberof ShopCreateRequest
     */
    'latitude': number;
    /**
     * 경도
     * @type {number}
     * @memberof ShopCreateRequest
     */
    'longitude': number;
    /**
     * 사업자 등록번호
     * @type {string}
     * @memberof ShopCreateRequest
     */
    'businessCode': string;
    /**
     * 음식 카테고리 (아래 값 중 하나를 입력하세요): - CHICKEN: 치킨 - CHINESE: 중식 - JAPANESE: 일식 - PIZZA: 피자 - FASTFOOD: 패스트푸드 - STEW_SOUP: 찜/탕 - JOK_BO: 족발/보쌈 - KOREAN: 한식 - SNACK: 분식 - WESTERN: 양식 - DESSERT: 카페/디저트 
     * @type {string}
     * @memberof ShopCreateRequest
     */
    'category': ShopCreateRequestCategoryEnum;
    /**
     * 예약 수수료
     * @type {number}
     * @memberof ShopCreateRequest
     */
    'reservationFee': number;
    /**
     * 영업 시작 시간
     * @type {string}
     * @memberof ShopCreateRequest
     */
    'openTime'?: string;
    /**
     * 영업 종료 시간
     * @type {string}
     * @memberof ShopCreateRequest
     */
    'closeTime'?: string;
    /**
     * 상점 설명
     * @type {string}
     * @memberof ShopCreateRequest
     */
    'description': string;
    /**
     * 전화번호
     * @type {string}
     * @memberof ShopCreateRequest
     */
    'tel': string;
    /**
     * 
     * @type {number}
     * @memberof ShopCreateRequest
     */
    'imageCount'?: number;
}

export const ShopCreateRequestCategoryEnum = {
    Chicken: 'CHICKEN',
    Chinese: 'CHINESE',
    Japanese: 'JAPANESE',
    Pizza: 'PIZZA',
    Fastfood: 'FASTFOOD',
    StewSoup: 'STEW_SOUP',
    JokBo: 'JOK_BO',
    Korean: 'KOREAN',
    Snack: 'SNACK',
    Western: 'WESTERN',
    Dessert: 'DESSERT'
} as const;

export type ShopCreateRequestCategoryEnum = typeof ShopCreateRequestCategoryEnum[keyof typeof ShopCreateRequestCategoryEnum];

/**
 * 
 * @export
 * @interface ShopDetailResponse
 */
export interface ShopDetailResponse {
    /**
     * 
     * @type {number}
     * @memberof ShopDetailResponse
     */
    'shopId'?: number;
    /**
     * 
     * @type {string}
     * @memberof ShopDetailResponse
     */
    'shopName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShopDetailResponse
     */
    'category'?: ShopDetailResponseCategoryEnum;
    /**
     * 
     * @type {string}
     * @memberof ShopDetailResponse
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShopDetailResponse
     */
    'roadAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShopDetailResponse
     */
    'detailAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShopDetailResponse
     */
    'tel'?: string;
    /**
     * 
     * @type {LocalTime}
     * @memberof ShopDetailResponse
     */
    'openTime'?: LocalTime;
    /**
     * 
     * @type {LocalTime}
     * @memberof ShopDetailResponse
     */
    'closeTime'?: LocalTime;
    /**
     * 
     * @type {number}
     * @memberof ShopDetailResponse
     */
    'rating'?: number;
    /**
     * 
     * @type {number}
     * @memberof ShopDetailResponse
     */
    'reservationFee'?: number;
    /**
     * 
     * @type {number}
     * @memberof ShopDetailResponse
     */
    'reviewCount'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ShopDetailResponse
     */
    'images'?: Array<string>;
}

export const ShopDetailResponseCategoryEnum = {
    Chicken: 'CHICKEN',
    Chinese: 'CHINESE',
    Japanese: 'JAPANESE',
    Pizza: 'PIZZA',
    Fastfood: 'FASTFOOD',
    StewSoup: 'STEW_SOUP',
    JokBo: 'JOK_BO',
    Korean: 'KOREAN',
    Snack: 'SNACK',
    Western: 'WESTERN',
    Dessert: 'DESSERT'
} as const;

export type ShopDetailResponseCategoryEnum = typeof ShopDetailResponseCategoryEnum[keyof typeof ShopDetailResponseCategoryEnum];

/**
 * 
 * @export
 * @interface ShopElementResponse
 */
export interface ShopElementResponse {
    /**
     * 
     * @type {number}
     * @memberof ShopElementResponse
     */
    'shopId'?: number;
    /**
     * 
     * @type {string}
     * @memberof ShopElementResponse
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShopElementResponse
     */
    'category'?: ShopElementResponseCategoryEnum;
    /**
     * 
     * @type {string}
     * @memberof ShopElementResponse
     */
    'address'?: string;
    /**
     * 
     * @type {number}
     * @memberof ShopElementResponse
     */
    'rating'?: number;
    /**
     * 
     * @type {string}
     * @memberof ShopElementResponse
     */
    'thumbnailUrl'?: string;
}

export const ShopElementResponseCategoryEnum = {
    Chicken: 'CHICKEN',
    Chinese: 'CHINESE',
    Japanese: 'JAPANESE',
    Pizza: 'PIZZA',
    Fastfood: 'FASTFOOD',
    StewSoup: 'STEW_SOUP',
    JokBo: 'JOK_BO',
    Korean: 'KOREAN',
    Snack: 'SNACK',
    Western: 'WESTERN',
    Dessert: 'DESSERT'
} as const;

export type ShopElementResponseCategoryEnum = typeof ShopElementResponseCategoryEnum[keyof typeof ShopElementResponseCategoryEnum];

/**
 * 
 * @export
 * @interface ShopOwnerDetailResponse
 */
export interface ShopOwnerDetailResponse {
    /**
     * 
     * @type {number}
     * @memberof ShopOwnerDetailResponse
     */
    'shopId'?: number;
    /**
     * 
     * @type {string}
     * @memberof ShopOwnerDetailResponse
     */
    'shopName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShopOwnerDetailResponse
     */
    'category'?: ShopOwnerDetailResponseCategoryEnum;
    /**
     * 
     * @type {string}
     * @memberof ShopOwnerDetailResponse
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShopOwnerDetailResponse
     */
    'roadAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShopOwnerDetailResponse
     */
    'detailAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShopOwnerDetailResponse
     */
    'tel'?: string;
    /**
     * 
     * @type {LocalTime}
     * @memberof ShopOwnerDetailResponse
     */
    'openTime'?: LocalTime;
    /**
     * 
     * @type {LocalTime}
     * @memberof ShopOwnerDetailResponse
     */
    'closeTime'?: LocalTime;
    /**
     * 
     * @type {number}
     * @memberof ShopOwnerDetailResponse
     */
    'rating'?: number;
    /**
     * 
     * @type {number}
     * @memberof ShopOwnerDetailResponse
     */
    'reservationFee'?: number;
    /**
     * 
     * @type {number}
     * @memberof ShopOwnerDetailResponse
     */
    'reviewCount'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ShopOwnerDetailResponse
     */
    'images'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ShopOwnerDetailResponse
     */
    'businessCode'?: string;
}

export const ShopOwnerDetailResponseCategoryEnum = {
    Chicken: 'CHICKEN',
    Chinese: 'CHINESE',
    Japanese: 'JAPANESE',
    Pizza: 'PIZZA',
    Fastfood: 'FASTFOOD',
    StewSoup: 'STEW_SOUP',
    JokBo: 'JOK_BO',
    Korean: 'KOREAN',
    Snack: 'SNACK',
    Western: 'WESTERN',
    Dessert: 'DESSERT'
} as const;

export type ShopOwnerDetailResponseCategoryEnum = typeof ShopOwnerDetailResponseCategoryEnum[keyof typeof ShopOwnerDetailResponseCategoryEnum];

/**
 * 
 * @export
 * @interface ShopPageResponse
 */
export interface ShopPageResponse {
    /**
     * 
     * @type {string}
     * @memberof ShopPageResponse
     */
    'nextCursor'?: string;
    /**
     * 
     * @type {Array<ShopElementResponse>}
     * @memberof ShopPageResponse
     */
    'shops'?: Array<ShopElementResponse>;
}
/**
 * 
 * @export
 * @interface ShopUpdateRequest
 */
export interface ShopUpdateRequest {
    /**
     * 상점 이름
     * @type {string}
     * @memberof ShopUpdateRequest
     */
    'shopName'?: string;
    /**
     * 도로명 주소
     * @type {string}
     * @memberof ShopUpdateRequest
     */
    'roadAddress'?: string;
    /**
     * 상세 주소
     * @type {string}
     * @memberof ShopUpdateRequest
     */
    'detailAddress'?: string;
    /**
     * 시/도
     * @type {string}
     * @memberof ShopUpdateRequest
     */
    'sido'?: string;
    /**
     * 위도
     * @type {number}
     * @memberof ShopUpdateRequest
     */
    'latitude'?: number;
    /**
     * 경도
     * @type {number}
     * @memberof ShopUpdateRequest
     */
    'longitude'?: number;
    /**
     * 사업자 등록번호
     * @type {string}
     * @memberof ShopUpdateRequest
     */
    'businessCode'?: string;
    /**
     * 음식 카테고리
     * @type {string}
     * @memberof ShopUpdateRequest
     */
    'category'?: ShopUpdateRequestCategoryEnum;
    /**
     * 예약 수수료
     * @type {number}
     * @memberof ShopUpdateRequest
     */
    'reservationFee'?: number;
    /**
     * 
     * @type {LocalTime}
     * @memberof ShopUpdateRequest
     */
    'openTime'?: LocalTime;
    /**
     * 
     * @type {LocalTime}
     * @memberof ShopUpdateRequest
     */
    'closeTime'?: LocalTime;
    /**
     * 상점 설명
     * @type {string}
     * @memberof ShopUpdateRequest
     */
    'description'?: string;
    /**
     * 전화번호
     * @type {string}
     * @memberof ShopUpdateRequest
     */
    'tel'?: string;
    /**
     * 이미지 개수
     * @type {number}
     * @memberof ShopUpdateRequest
     */
    'imageCount'?: number;
}

export const ShopUpdateRequestCategoryEnum = {
    Chicken: 'CHICKEN',
    Chinese: 'CHINESE',
    Japanese: 'JAPANESE',
    Pizza: 'PIZZA',
    Fastfood: 'FASTFOOD',
    StewSoup: 'STEW_SOUP',
    JokBo: 'JOK_BO',
    Korean: 'KOREAN',
    Snack: 'SNACK',
    Western: 'WESTERN',
    Dessert: 'DESSERT'
} as const;

export type ShopUpdateRequestCategoryEnum = typeof ShopUpdateRequestCategoryEnum[keyof typeof ShopUpdateRequestCategoryEnum];

/**
 * 
 * @export
 * @interface ShopsItem
 */
export interface ShopsItem {
    /**
     * 
     * @type {number}
     * @memberof ShopsItem
     */
    'shopId'?: number;
    /**
     * 
     * @type {string}
     * @memberof ShopsItem
     */
    'shopName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShopsItem
     */
    'category'?: ShopsItemCategoryEnum;
    /**
     * 
     * @type {string}
     * @memberof ShopsItem
     */
    'roadAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShopsItem
     */
    'detailAddress'?: string;
    /**
     * 
     * @type {number}
     * @memberof ShopsItem
     */
    'latitude'?: number;
    /**
     * 
     * @type {number}
     * @memberof ShopsItem
     */
    'longitude'?: number;
    /**
     * 
     * @type {number}
     * @memberof ShopsItem
     */
    'rating'?: number;
    /**
     * 
     * @type {string}
     * @memberof ShopsItem
     */
    'thumbnailUrl'?: string;
}

export const ShopsItemCategoryEnum = {
    Chicken: 'CHICKEN',
    Chinese: 'CHINESE',
    Japanese: 'JAPANESE',
    Pizza: 'PIZZA',
    Fastfood: 'FASTFOOD',
    StewSoup: 'STEW_SOUP',
    JokBo: 'JOK_BO',
    Korean: 'KOREAN',
    Snack: 'SNACK',
    Western: 'WESTERN',
    Dessert: 'DESSERT'
} as const;

export type ShopsItemCategoryEnum = typeof ShopsItemCategoryEnum[keyof typeof ShopsItemCategoryEnum];

/**
 * 
 * @export
 * @interface ShopsResponse
 */
export interface ShopsResponse {
    /**
     * 
     * @type {number}
     * @memberof ShopsResponse
     */
    'nextCursor'?: number;
    /**
     * 
     * @type {Array<ShopsItem>}
     * @memberof ShopsResponse
     */
    'content'?: Array<ShopsItem>;
}
/**
 * 
 * @export
 * @interface SignUpRequest
 */
export interface SignUpRequest {
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    'nickname': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    'phoneNumber': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof SignUpRequest
     */
    'age'?: number;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    'gender': SignUpRequestGenderEnum;
}

export const SignUpRequestGenderEnum = {
    M: 'M',
    W: 'W'
} as const;

export type SignUpRequestGenderEnum = typeof SignUpRequestGenderEnum[keyof typeof SignUpRequestGenderEnum];

/**
 * 
 * @export
 * @interface TossPaymentConfirmRequest
 */
export interface TossPaymentConfirmRequest {
    /**
     * 
     * @type {string}
     * @memberof TossPaymentConfirmRequest
     */
    'paymentKey': string;
    /**
     * 
     * @type {string}
     * @memberof TossPaymentConfirmRequest
     */
    'orderId': string;
    /**
     * 
     * @type {number}
     * @memberof TossPaymentConfirmRequest
     */
    'amount': number;
}
/**
 * 
 * @export
 * @interface Writer
 */
export interface Writer {
    /**
     * 
     * @type {number}
     * @memberof Writer
     */
    'userId'?: number;
    /**
     * 
     * @type {string}
     * @memberof Writer
     */
    'nickname'?: string;
}

/**
 * APIApi - axios parameter creator
 * @export
 */
export const APIApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminTest: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/test`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 모집중인 파티를 모집종료 상태로 변경합니다.(Completed)
         * @summary 파티 모집 완료 상태 변경
         * @param {number} partyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeParty: async (partyId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partyId' is not null or undefined
            assertParamExists('completeParty', 'partyId', partyId)
            const localVarPath = `/parties/{partyId}/complete`
                .replace(`{${"partyId"}}`, encodeURIComponent(String(partyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * TOSS_SECRET_KEY=test_gsk_docs_OaPz8L5KdmQXkzRz3y47BMw6 TOSS_CLIENT_KEY=test_gck_docs_Ovk5rk1EwkEbP0W43n07xlzm 혹여나 프론트와 토스페이 api 통신이 되지 않으면  https://github.com/prgrms-be-devcourse/NBE5-7-2-Team09  링크에 프론트 코드 링크 참조해주세요
         * @summary Confirm
         * @param {TossPaymentConfirmRequest} tossPaymentConfirmRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirm: async (tossPaymentConfirmRequest: TossPaymentConfirmRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tossPaymentConfirmRequest' is not null or undefined
            assertParamExists('confirm', 'tossPaymentConfirmRequest', tossPaymentConfirmRequest)
            const localVarPath = `/api/payments/confirm`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tossPaymentConfirmRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * reservationId에 해당하는 예약을 CONFIRMED 상태로 변경한다. (Completed)
         * @summary 예약 수락
         * @param {number} reservationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmReservation: async (reservationId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reservationId' is not null or undefined
            assertParamExists('confirmReservation', 'reservationId', reservationId)
            const localVarPath = `/reservations/{reservationId}/confirm`
                .replace(`{${"reservationId"}}`, encodeURIComponent(String(reservationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 특정 모임에 댓글을 작성합니다.(Completed)
         * @summary 댓글 작성
         * @param {number} partyId 
         * @param {CommentCreateRequest} commentCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createComment: async (partyId: number, commentCreateRequest: CommentCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partyId' is not null or undefined
            assertParamExists('createComment', 'partyId', partyId)
            // verify required parameter 'commentCreateRequest' is not null or undefined
            assertParamExists('createComment', 'commentCreateRequest', commentCreateRequest)
            const localVarPath = `/parties/{partyId}/comments`
                .replace(`{${"partyId"}}`, encodeURIComponent(String(partyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(commentCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 맛집 탐험 파티 모집 게시글을 작성합니다.(Completed)
         * @summary 파티 생성
         * @param {PartyCreateRequest} partyCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createParty: async (partyCreateRequest: PartyCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partyCreateRequest' is not null or undefined
            assertParamExists('createParty', 'partyCreateRequest', partyCreateRequest)
            const localVarPath = `/parties`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(partyCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * shopId에 해당하는 식당에 예약을 생성한다. 파티 예약인 경우 partyId를 쿼리 파라미터로 전달해야 한다.(Completed)
         * @summary 예약 생성
         * @param {number} shopId 
         * @param {CreateReservationRequest} createReservationRequest 
         * @param {number} [partyId] 파티 ID (선택값). 파티 예약일 경우 전달.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReservation: async (shopId: number, createReservationRequest: CreateReservationRequest, partyId?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shopId' is not null or undefined
            assertParamExists('createReservation', 'shopId', shopId)
            // verify required parameter 'createReservationRequest' is not null or undefined
            assertParamExists('createReservation', 'createReservationRequest', createReservationRequest)
            const localVarPath = `/shops/{shopId}/reservations`
                .replace(`{${"shopId"}}`, encodeURIComponent(String(shopId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (partyId !== undefined) {
                localVarQueryParameter['partyId'] = partyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createReservationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 리뷰를 작성합니다.(Completed)
         * @summary 리뷰 작성
         * @param {ReviewCreateRequest} reviewCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReview: async (reviewCreateRequest: ReviewCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reviewCreateRequest' is not null or undefined
            assertParamExists('createReview', 'reviewCreateRequest', reviewCreateRequest)
            const localVarPath = `/reviews`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reviewCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 새로운 식당을 생성합니다.(Completed)
         * @summary 식당 생성
         * @param {ShopCreateRequest} shopCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShop: async (shopCreateRequest: ShopCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shopCreateRequest' is not null or undefined
            assertParamExists('createShop', 'shopCreateRequest', shopCreateRequest)
            const localVarPath = `/shops/presigned-urls`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shopCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 특정 댓글을 삭제합니다.(Completed)
         * @summary 댓글 삭제
         * @param {number} commentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteComment: async (commentId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('deleteComment', 'commentId', commentId)
            const localVarPath = `/comments/{commentId}`
                .replace(`{${"commentId"}}`, encodeURIComponent(String(commentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 맛집 탐험 파티 게시글을 삭제합니다.(Completed)
         * @summary 파티 삭제
         * @param {number} partyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteParty: async (partyId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partyId' is not null or undefined
            assertParamExists('deleteParty', 'partyId', partyId)
            const localVarPath = `/parties/{partyId}`
                .replace(`{${"partyId"}}`, encodeURIComponent(String(partyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 프로필 수정 작업 중 예외 발생으로 업로드된 이미지를 삭제합니다.(Completed)
         * @summary 프로필 이미지 삭제
         * @param {DeleteProfileRequest} deleteProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProfile: async (deleteProfileRequest: DeleteProfileRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteProfileRequest' is not null or undefined
            assertParamExists('deleteProfile', 'deleteProfileRequest', deleteProfileRequest)
            const localVarPath = `/users/my-page/profile-img`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteProfileRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 특정 리뷰를 삭제합니다.(Completed)
         * @summary 리뷰 삭제
         * @param {number} reviewId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReview: async (reviewId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reviewId' is not null or undefined
            assertParamExists('deleteReview', 'reviewId', reviewId)
            const localVarPath = `/reviews/{reviewId}`
                .replace(`{${"reviewId"}}`, encodeURIComponent(String(reviewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 회원 탈퇴 기능(Inprogress)
         * @summary 회원탈퇴
         * @param {string} refreshToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (refreshToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refreshToken' is not null or undefined
            assertParamExists('deleteUser', 'refreshToken', refreshToken)
            const localVarPath = `/users/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 특정 모임의 댓글 목록을 조회합니다.(Completed)
         * @summary 댓글 조회
         * @param {number} partyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComments: async (partyId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partyId' is not null or undefined
            assertParamExists('getComments', 'partyId', partyId)
            const localVarPath = `/parties/{partyId}/comments`
                .replace(`{${"partyId"}}`, encodeURIComponent(String(partyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 특정 식당의 상세 정보를 조회합니다. (Completed)
         * @summary 식당 상세 조회
         * @param {number} shopId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDetailShop: async (shopId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shopId' is not null or undefined
            assertParamExists('getDetailShop', 'shopId', shopId)
            const localVarPath = `/shops/{shopId}`
                .replace(`{${"shopId"}}`, encodeURIComponent(String(shopId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 특정 식당의 상세 정보를 조회합니다. (Completed)
         * @summary 사장의 식당 상세 조회
         * @param {number} shopId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDetailShopOwner: async (shopId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shopId' is not null or undefined
            assertParamExists('getDetailShopOwner', 'shopId', shopId)
            const localVarPath = `/owner/shops/{shopId}`
                .replace(`{${"shopId"}}`, encodeURIComponent(String(shopId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 로그인한 사용자의 마이페이지 정보를 조회합니다.(Completed)
         * @summary 내 정보 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyInfo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/my-page`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 로그인한 사용자의 파티 목록을 커서 기반 페이징 방식으로 조회합니다.(Completed)
         * @summary 내 파티 정보 조회
         * @param {number} [size] 
         * @param {number} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyParties: async (size?: number, cursor?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/my-page/parties`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 로그인한 사용자의 예약 목록을 커서 기반 페이징 방식으로 조회합니다.(Completed)
         * @summary 내 예약 정보 조회
         * @param {number} [size] 
         * @param {number} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyReservations: async (size?: number, cursor?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/my-page/reservations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 로그인한 사용자가 작성한 리뷰 목록을 커서 기반 페이징 방식으로 조회합니다.(Completed)
         * @summary 내 리뷰 정보 조회
         * @param {number} [size] 
         * @param {number} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyReviews: async (size?: number, cursor?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/my-page/reviews`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 사장 한명이 가진 식당들 리스트들을 조회합니다.(Completed)
         * @summary 사장이 가진 식당들 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOwnerShops: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/owner/shops`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 파티 상태, 위치, 음식 카테고리로 필터링한 파티 게시글 목록을 조회합니다. (Completed)  예시 /parties?status=RECRUITING&minAge=10&categories=CHICKEN&categories=JAPANESE  | 필드 명     | 자료형    | 필수 여부  | 설명                                            | 기본값                   | |------------|---------|-----------|-------------------------------------------------|------------------------| | status     | string  | Optional  | 파티 상태                                        | 전체                    | | gender     | string  | Optional  | 모집 성별 조건(A일 시 성별 무관인 파티만 조회합니다.)   |  전체                   | | minAge     | int     | Optional  | 모집 최소 나이                                    | 전체                    | | maxAge     | int     | Optional  | 모집 최대 나이                                    | 전체                    | | location   | string  | Optional  | 시/도 단위 파티 위치                               | 전체                    | | category   | string  | Optional  | 음식 카테고리 (다중 선택 가능)                       | 전체                    | | query      | string  | Optional  | 파티 제목 검색 키워드                               | 전체                    | | cursor       | int  | Optional   | 페이징 마지막 파티 id                               | 첫번째 페이지            | 
         * @summary 파티 목록 조회
         * @param {GetPartiesStatusEnum} [status] 
         * @param {GetPartiesGenderEnum} [gender] 
         * @param {number} [minAge] 
         * @param {number} [maxAge] 
         * @param {string} [location] 
         * @param {Array<GetPartiesCategoriesEnum>} [categories] 
         * @param {string} [query] 
         * @param {number} [cursor] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParties: async (status?: GetPartiesStatusEnum, gender?: GetPartiesGenderEnum, minAge?: number, maxAge?: number, location?: string, categories?: Array<GetPartiesCategoriesEnum>, query?: string, cursor?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/parties`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (gender !== undefined) {
                localVarQueryParameter['gender'] = gender;
            }

            if (minAge !== undefined) {
                localVarQueryParameter['minAge'] = minAge;
            }

            if (maxAge !== undefined) {
                localVarQueryParameter['maxAge'] = maxAge;
            }

            if (location !== undefined) {
                localVarQueryParameter['location'] = location;
            }

            if (categories) {
                localVarQueryParameter['categories'] = categories;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 맛집 탐험 파티 게시글 상세 정보를 조회합니다.(Completed)
         * @summary 파티 상세 조회
         * @param {number} partyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartyDetail: async (partyId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partyId' is not null or undefined
            assertParamExists('getPartyDetail', 'partyId', partyId)
            const localVarPath = `/parties/{partyId}`
                .replace(`{${"partyId"}}`, encodeURIComponent(String(partyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 내 정보 수정 항목 중 프로필 이미지를 업로드하기 위한 pre-signed url을 생성합니다.(Completed)
         * @summary 프로필 이미지 업로드를 위한 pre-signed url 생성
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfilePresignedUrl: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/my-page/presigned-urls`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 식당의 예약 목록을 필터와 커서 기반으로 조회한다.(Completed)
         * @summary 식당 예약 목록 조회
         * @param {GetReservationsFilterEnum} [filter] 
         * @param {number} [cursor] 
         * @param {number} [size] 
         * @param {number} [shopId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReservations: async (filter?: GetReservationsFilterEnum, cursor?: number, size?: number, shopId?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/reservations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (shopId !== undefined) {
                localVarQueryParameter['shopId'] = shopId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 특정 가게의 리뷰 목록을 조회합니다.(Completed)
         * @summary 리뷰 조회
         * @param {number} shopId 
         * @param {number} [cursor] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReviews: async (shopId: number, cursor?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shopId' is not null or undefined
            assertParamExists('getReviews', 'shopId', shopId)
            const localVarPath = `/shops/{shopId}/reviews`
                .replace(`{${"shopId"}}`, encodeURIComponent(String(shopId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 위치 기반으로 식당 목록을 조회합니다. (Completed)  반경은 m 단위로 주시면 되며 ->  3km (3000) 만약 사용자가 자신의 위치를 허용한다면 latitude과 longitude에 사용자 위도 경도, 원하는 범위를 넣어서 요청을 보내고 그렇지 않는다면 기본값으론 종로구 좌표에 3km 범위 식당을 가져옵니다  예시 /shops?radius=1000000&sort=rating  | 필드 명     | 자료형  | 필수 여부 | 설명                   | 기본값           | |------------|---------|-----------|-------------------------|------------------| | latitude   | double  | Required  | 사용자 위치의 위도         | 37.5724          | | longitude  | double  | Required  | 사용자 위치의 경도         | 126.9794         | | radius     | double  | Optional  | 검색 반경 (단위: m)       | 3000.0           | | category   | string  | Optional  | 음식 카테고리             | 전체             | | sort       | string  | Optional  | 정렬 기준 (근처순, 평점순) | 근처 순(distance) |  
         * @summary 식당 목록 조회
         * @param {number} [latitude] 
         * @param {number} [longitude] 
         * @param {number} [radius] 
         * @param {Array<GetShopsCategoryEnum>} [category] 
         * @param {string} [sort] 
         * @param {number} [cursor] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShops: async (latitude?: number, longitude?: number, radius?: number, category?: Array<GetShopsCategoryEnum>, sort?: string, cursor?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/shops`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (latitude !== undefined) {
                localVarQueryParameter['latitude'] = latitude;
            }

            if (longitude !== undefined) {
                localVarQueryParameter['longitude'] = longitude;
            }

            if (radius !== undefined) {
                localVarQueryParameter['radius'] = radius;
            }

            if (category) {
                localVarQueryParameter['category'] = category;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 키워드로 식당을 검색합니다.정렬기준: NAME, CREATED_AT, RATING  (Completed)
         * @summary 식당 검색
         * @param {string} [query] 
         * @param {GetShopsBySearchSortEnum} [sort] 
         * @param {string} [cursor] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShopsBySearch: async (query?: string, sort?: GetShopsBySearchSortEnum, cursor?: string, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/shops/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 맛집 탐험 파티를 참여합니다.(Completed)
         * @summary 파티 참여
         * @param {number} partyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinParty: async (partyId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partyId' is not null or undefined
            assertParamExists('joinParty', 'partyId', partyId)
            const localVarPath = `/parties/{partyId}/join`
                .replace(`{${"partyId"}}`, encodeURIComponent(String(partyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 폼 로그인으로 로그인합니다. 성공 시 액세스 토큰은 헤더, 리프레시 토큰은 쿠키에 포함됩니다.(Completed)
         * @summary Form 로그인
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginRequest: LoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginRequest' is not null or undefined
            assertParamExists('login', 'loginRequest', loginRequest)
            const localVarPath = `/users/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 쿠키의 리프레시 토큰을 무효화하고 로그아웃 처리합니다.
         * @summary 로그아웃
         * @param {string} refreshToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (refreshToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refreshToken' is not null or undefined
            assertParamExists('logout', 'refreshToken', refreshToken)
            const localVarPath = `/users/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 프론트는 이 URL로 리디렉션하여 OAuth2 로그인을 시작합니다. 예: /oauth2/authorization/google
         * @summary OAuth2 로그인 진입점 URL 안내
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauth2Urls: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/authorization-info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * OAuth 추가 회원가입(Completed)
         * @summary 회원가입
         * @param {OAuthSignUpRequest} oAuthSignUpRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthSignup: async (oAuthSignUpRequest: OAuthSignUpRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'oAuthSignUpRequest' is not null or undefined
            assertParamExists('oauthSignup', 'oAuthSignUpRequest', oAuthSignUpRequest)
            const localVarPath = `/users/signup/oauth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(oAuthSignUpRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ownerTest: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/owner/test`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 맛집 탐험 파티를 참여를 취소합니다.(Completed)
         * @summary 파티 탈퇴
         * @param {number} partyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quitParty: async (partyId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partyId' is not null or undefined
            assertParamExists('quitParty', 'partyId', partyId)
            const localVarPath = `/parties/{partyId}/quit`
                .replace(`{${"partyId"}}`, encodeURIComponent(String(partyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 쿠키의 리프레시 토큰을 이용해 새로운 액세스 토큰을 재발급합니다.
         * @summary 액세스 토큰 재발급
         * @param {string} refreshToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken: async (refreshToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refreshToken' is not null or undefined
            assertParamExists('refreshToken', 'refreshToken', refreshToken)
            const localVarPath = `/users/reissue-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * reservationId에 해당하는 예약을 CANCELLED 상태로 변경한다. (Completed)
         * @summary 예약 거절
         * @param {number} reservationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refuseReservation: async (reservationId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reservationId' is not null or undefined
            assertParamExists('refuseReservation', 'reservationId', reservationId)
            const localVarPath = `/reservations/{reservationId}/cancel`
                .replace(`{${"reservationId"}}`, encodeURIComponent(String(reservationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 폼 로그인 회원가입(Completed)
         * @summary 회원가입
         * @param {SignUpRequest} signUpRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signup: async (signUpRequest: SignUpRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signUpRequest' is not null or undefined
            assertParamExists('signup', 'signUpRequest', signUpRequest)
            const localVarPath = `/users/signup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signUpRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 로그인한 사용자의 마이페이지 정보를 수정합니다.(Completed)
         * @summary 내 정보 수정
         * @param {MyInfoUpdateRequest} myInfoUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMyInfo: async (myInfoUpdateRequest: MyInfoUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'myInfoUpdateRequest' is not null or undefined
            assertParamExists('updateMyInfo', 'myInfoUpdateRequest', myInfoUpdateRequest)
            const localVarPath = `/users/my-page`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(myInfoUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 식당 정보를 수정합니다. (Completed)
         * @summary 사장 식당 정보 수정
         * @param {number} shopId 
         * @param {ShopUpdateRequest} shopUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShop: async (shopId: number, shopUpdateRequest: ShopUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shopId' is not null or undefined
            assertParamExists('updateShop', 'shopId', shopId)
            // verify required parameter 'shopUpdateRequest' is not null or undefined
            assertParamExists('updateShop', 'shopUpdateRequest', shopUpdateRequest)
            const localVarPath = `/owner/shops/{shopId}`
                .replace(`{${"shopId"}}`, encodeURIComponent(String(shopId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shopUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userTest: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/test`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * APIApi - functional programming interface
 * @export
 */
export const APIApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = APIApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminTest(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminTest(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIApi.adminTest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 모집중인 파티를 모집종료 상태로 변경합니다.(Completed)
         * @summary 파티 모집 완료 상태 변경
         * @param {number} partyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeParty(partyId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeParty(partyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIApi.completeParty']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * TOSS_SECRET_KEY=test_gsk_docs_OaPz8L5KdmQXkzRz3y47BMw6 TOSS_CLIENT_KEY=test_gck_docs_Ovk5rk1EwkEbP0W43n07xlzm 혹여나 프론트와 토스페이 api 통신이 되지 않으면  https://github.com/prgrms-be-devcourse/NBE5-7-2-Team09  링크에 프론트 코드 링크 참조해주세요
         * @summary Confirm
         * @param {TossPaymentConfirmRequest} tossPaymentConfirmRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async confirm(tossPaymentConfirmRequest: TossPaymentConfirmRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponsePaymentSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.confirm(tossPaymentConfirmRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIApi.confirm']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * reservationId에 해당하는 예약을 CONFIRMED 상태로 변경한다. (Completed)
         * @summary 예약 수락
         * @param {number} reservationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async confirmReservation(reservationId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.confirmReservation(reservationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIApi.confirmReservation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 특정 모임에 댓글을 작성합니다.(Completed)
         * @summary 댓글 작성
         * @param {number} partyId 
         * @param {CommentCreateRequest} commentCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createComment(partyId: number, commentCreateRequest: CommentCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createComment(partyId, commentCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIApi.createComment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 맛집 탐험 파티 모집 게시글을 작성합니다.(Completed)
         * @summary 파티 생성
         * @param {PartyCreateRequest} partyCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createParty(partyCreateRequest: PartyCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createParty(partyCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIApi.createParty']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * shopId에 해당하는 식당에 예약을 생성한다. 파티 예약인 경우 partyId를 쿼리 파라미터로 전달해야 한다.(Completed)
         * @summary 예약 생성
         * @param {number} shopId 
         * @param {CreateReservationRequest} createReservationRequest 
         * @param {number} [partyId] 파티 ID (선택값). 파티 예약일 경우 전달.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createReservation(shopId: number, createReservationRequest: CreateReservationRequest, partyId?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateReservationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createReservation(shopId, createReservationRequest, partyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIApi.createReservation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 리뷰를 작성합니다.(Completed)
         * @summary 리뷰 작성
         * @param {ReviewCreateRequest} reviewCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createReview(reviewCreateRequest: ReviewCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponsePreSignedUrlListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createReview(reviewCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIApi.createReview']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 새로운 식당을 생성합니다.(Completed)
         * @summary 식당 생성
         * @param {ShopCreateRequest} shopCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createShop(shopCreateRequest: ShopCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponsePreSignedUrlListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createShop(shopCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIApi.createShop']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 특정 댓글을 삭제합니다.(Completed)
         * @summary 댓글 삭제
         * @param {number} commentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteComment(commentId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteComment(commentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIApi.deleteComment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 맛집 탐험 파티 게시글을 삭제합니다.(Completed)
         * @summary 파티 삭제
         * @param {number} partyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteParty(partyId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteParty(partyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIApi.deleteParty']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 프로필 수정 작업 중 예외 발생으로 업로드된 이미지를 삭제합니다.(Completed)
         * @summary 프로필 이미지 삭제
         * @param {DeleteProfileRequest} deleteProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProfile(deleteProfileRequest: DeleteProfileRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProfile(deleteProfileRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIApi.deleteProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 특정 리뷰를 삭제합니다.(Completed)
         * @summary 리뷰 삭제
         * @param {number} reviewId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteReview(reviewId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteReview(reviewId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIApi.deleteReview']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 회원 탈퇴 기능(Inprogress)
         * @summary 회원탈퇴
         * @param {string} refreshToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(refreshToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(refreshToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIApi.deleteUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 특정 모임의 댓글 목록을 조회합니다.(Completed)
         * @summary 댓글 조회
         * @param {number} partyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getComments(partyId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseListCommentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getComments(partyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIApi.getComments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 특정 식당의 상세 정보를 조회합니다. (Completed)
         * @summary 식당 상세 조회
         * @param {number} shopId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDetailShop(shopId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseShopDetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDetailShop(shopId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIApi.getDetailShop']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 특정 식당의 상세 정보를 조회합니다. (Completed)
         * @summary 사장의 식당 상세 조회
         * @param {number} shopId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDetailShopOwner(shopId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseShopOwnerDetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDetailShopOwner(shopId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIApi.getDetailShopOwner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 로그인한 사용자의 마이페이지 정보를 조회합니다.(Completed)
         * @summary 내 정보 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMyInfo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseMyInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMyInfo(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIApi.getMyInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 로그인한 사용자의 파티 목록을 커서 기반 페이징 방식으로 조회합니다.(Completed)
         * @summary 내 파티 정보 조회
         * @param {number} [size] 
         * @param {number} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMyParties(size?: number, cursor?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseMyPartyPageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMyParties(size, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIApi.getMyParties']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 로그인한 사용자의 예약 목록을 커서 기반 페이징 방식으로 조회합니다.(Completed)
         * @summary 내 예약 정보 조회
         * @param {number} [size] 
         * @param {number} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMyReservations(size?: number, cursor?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseMyReservationPageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMyReservations(size, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIApi.getMyReservations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 로그인한 사용자가 작성한 리뷰 목록을 커서 기반 페이징 방식으로 조회합니다.(Completed)
         * @summary 내 리뷰 정보 조회
         * @param {number} [size] 
         * @param {number} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMyReviews(size?: number, cursor?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseMyReviewPageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMyReviews(size, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIApi.getMyReviews']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 사장 한명이 가진 식당들 리스트들을 조회합니다.(Completed)
         * @summary 사장이 가진 식당들 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOwnerShops(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseOwnerShopsList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOwnerShops(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIApi.getOwnerShops']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 파티 상태, 위치, 음식 카테고리로 필터링한 파티 게시글 목록을 조회합니다. (Completed)  예시 /parties?status=RECRUITING&minAge=10&categories=CHICKEN&categories=JAPANESE  | 필드 명     | 자료형    | 필수 여부  | 설명                                            | 기본값                   | |------------|---------|-----------|-------------------------------------------------|------------------------| | status     | string  | Optional  | 파티 상태                                        | 전체                    | | gender     | string  | Optional  | 모집 성별 조건(A일 시 성별 무관인 파티만 조회합니다.)   |  전체                   | | minAge     | int     | Optional  | 모집 최소 나이                                    | 전체                    | | maxAge     | int     | Optional  | 모집 최대 나이                                    | 전체                    | | location   | string  | Optional  | 시/도 단위 파티 위치                               | 전체                    | | category   | string  | Optional  | 음식 카테고리 (다중 선택 가능)                       | 전체                    | | query      | string  | Optional  | 파티 제목 검색 키워드                               | 전체                    | | cursor       | int  | Optional   | 페이징 마지막 파티 id                               | 첫번째 페이지            | 
         * @summary 파티 목록 조회
         * @param {GetPartiesStatusEnum} [status] 
         * @param {GetPartiesGenderEnum} [gender] 
         * @param {number} [minAge] 
         * @param {number} [maxAge] 
         * @param {string} [location] 
         * @param {Array<GetPartiesCategoriesEnum>} [categories] 
         * @param {string} [query] 
         * @param {number} [cursor] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getParties(status?: GetPartiesStatusEnum, gender?: GetPartiesGenderEnum, minAge?: number, maxAge?: number, location?: string, categories?: Array<GetPartiesCategoriesEnum>, query?: string, cursor?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponsePartyScrollResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getParties(status, gender, minAge, maxAge, location, categories, query, cursor, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIApi.getParties']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 맛집 탐험 파티 게시글 상세 정보를 조회합니다.(Completed)
         * @summary 파티 상세 조회
         * @param {number} partyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPartyDetail(partyId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponsePartyDetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPartyDetail(partyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIApi.getPartyDetail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 내 정보 수정 항목 중 프로필 이미지를 업로드하기 위한 pre-signed url을 생성합니다.(Completed)
         * @summary 프로필 이미지 업로드를 위한 pre-signed url 생성
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProfilePresignedUrl(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponsePreSignedUrlResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProfilePresignedUrl(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIApi.getProfilePresignedUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 식당의 예약 목록을 필터와 커서 기반으로 조회한다.(Completed)
         * @summary 식당 예약 목록 조회
         * @param {GetReservationsFilterEnum} [filter] 
         * @param {number} [cursor] 
         * @param {number} [size] 
         * @param {number} [shopId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReservations(filter?: GetReservationsFilterEnum, cursor?: number, size?: number, shopId?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReservationListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReservations(filter, cursor, size, shopId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIApi.getReservations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 특정 가게의 리뷰 목록을 조회합니다.(Completed)
         * @summary 리뷰 조회
         * @param {number} shopId 
         * @param {number} [cursor] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReviews(shopId: number, cursor?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseReviewPageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReviews(shopId, cursor, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIApi.getReviews']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 위치 기반으로 식당 목록을 조회합니다. (Completed)  반경은 m 단위로 주시면 되며 ->  3km (3000) 만약 사용자가 자신의 위치를 허용한다면 latitude과 longitude에 사용자 위도 경도, 원하는 범위를 넣어서 요청을 보내고 그렇지 않는다면 기본값으론 종로구 좌표에 3km 범위 식당을 가져옵니다  예시 /shops?radius=1000000&sort=rating  | 필드 명     | 자료형  | 필수 여부 | 설명                   | 기본값           | |------------|---------|-----------|-------------------------|------------------| | latitude   | double  | Required  | 사용자 위치의 위도         | 37.5724          | | longitude  | double  | Required  | 사용자 위치의 경도         | 126.9794         | | radius     | double  | Optional  | 검색 반경 (단위: m)       | 3000.0           | | category   | string  | Optional  | 음식 카테고리             | 전체             | | sort       | string  | Optional  | 정렬 기준 (근처순, 평점순) | 근처 순(distance) |  
         * @summary 식당 목록 조회
         * @param {number} [latitude] 
         * @param {number} [longitude] 
         * @param {number} [radius] 
         * @param {Array<GetShopsCategoryEnum>} [category] 
         * @param {string} [sort] 
         * @param {number} [cursor] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getShops(latitude?: number, longitude?: number, radius?: number, category?: Array<GetShopsCategoryEnum>, sort?: string, cursor?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseShopsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getShops(latitude, longitude, radius, category, sort, cursor, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIApi.getShops']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 키워드로 식당을 검색합니다.정렬기준: NAME, CREATED_AT, RATING  (Completed)
         * @summary 식당 검색
         * @param {string} [query] 
         * @param {GetShopsBySearchSortEnum} [sort] 
         * @param {string} [cursor] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getShopsBySearch(query?: string, sort?: GetShopsBySearchSortEnum, cursor?: string, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseShopPageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getShopsBySearch(query, sort, cursor, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIApi.getShopsBySearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 맛집 탐험 파티를 참여합니다.(Completed)
         * @summary 파티 참여
         * @param {number} partyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async joinParty(partyId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.joinParty(partyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIApi.joinParty']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 폼 로그인으로 로그인합니다. 성공 시 액세스 토큰은 헤더, 리프레시 토큰은 쿠키에 포함됩니다.(Completed)
         * @summary Form 로그인
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIApi.login']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 쿠키의 리프레시 토큰을 무효화하고 로그아웃 처리합니다.
         * @summary 로그아웃
         * @param {string} refreshToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(refreshToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout(refreshToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIApi.logout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 프론트는 이 URL로 리디렉션하여 OAuth2 로그인을 시작합니다. 예: /oauth2/authorization/google
         * @summary OAuth2 로그인 진입점 URL 안내
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oauth2Urls(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: string; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oauth2Urls(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIApi.oauth2Urls']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * OAuth 추가 회원가입(Completed)
         * @summary 회원가입
         * @param {OAuthSignUpRequest} oAuthSignUpRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oauthSignup(oAuthSignUpRequest: OAuthSignUpRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oauthSignup(oAuthSignUpRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIApi.oauthSignup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ownerTest(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ownerTest(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIApi.ownerTest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 맛집 탐험 파티를 참여를 취소합니다.(Completed)
         * @summary 파티 탈퇴
         * @param {number} partyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async quitParty(partyId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.quitParty(partyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIApi.quitParty']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 쿠키의 리프레시 토큰을 이용해 새로운 액세스 토큰을 재발급합니다.
         * @summary 액세스 토큰 재발급
         * @param {string} refreshToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshToken(refreshToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseAccessTokenResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshToken(refreshToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIApi.refreshToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * reservationId에 해당하는 예약을 CANCELLED 상태로 변경한다. (Completed)
         * @summary 예약 거절
         * @param {number} reservationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refuseReservation(reservationId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refuseReservation(reservationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIApi.refuseReservation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 폼 로그인 회원가입(Completed)
         * @summary 회원가입
         * @param {SignUpRequest} signUpRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signup(signUpRequest: SignUpRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signup(signUpRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIApi.signup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 로그인한 사용자의 마이페이지 정보를 수정합니다.(Completed)
         * @summary 내 정보 수정
         * @param {MyInfoUpdateRequest} myInfoUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMyInfo(myInfoUpdateRequest: MyInfoUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMyInfo(myInfoUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIApi.updateMyInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 식당 정보를 수정합니다. (Completed)
         * @summary 사장 식당 정보 수정
         * @param {number} shopId 
         * @param {ShopUpdateRequest} shopUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateShop(shopId: number, shopUpdateRequest: ShopUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponsePreSignedUrlListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateShop(shopId, shopUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIApi.updateShop']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userTest(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userTest(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIApi.userTest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * APIApi - factory interface
 * @export
 */
export const APIApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = APIApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminTest(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.adminTest(options).then((request) => request(axios, basePath));
        },
        /**
         * 모집중인 파티를 모집종료 상태로 변경합니다.(Completed)
         * @summary 파티 모집 완료 상태 변경
         * @param {number} partyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeParty(partyId: number, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponseVoid> {
            return localVarFp.completeParty(partyId, options).then((request) => request(axios, basePath));
        },
        /**
         * TOSS_SECRET_KEY=test_gsk_docs_OaPz8L5KdmQXkzRz3y47BMw6 TOSS_CLIENT_KEY=test_gck_docs_Ovk5rk1EwkEbP0W43n07xlzm 혹여나 프론트와 토스페이 api 통신이 되지 않으면  https://github.com/prgrms-be-devcourse/NBE5-7-2-Team09  링크에 프론트 코드 링크 참조해주세요
         * @summary Confirm
         * @param {TossPaymentConfirmRequest} tossPaymentConfirmRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirm(tossPaymentConfirmRequest: TossPaymentConfirmRequest, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponsePaymentSuccessResponse> {
            return localVarFp.confirm(tossPaymentConfirmRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * reservationId에 해당하는 예약을 CONFIRMED 상태로 변경한다. (Completed)
         * @summary 예약 수락
         * @param {number} reservationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmReservation(reservationId: number, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponseVoid> {
            return localVarFp.confirmReservation(reservationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 특정 모임에 댓글을 작성합니다.(Completed)
         * @summary 댓글 작성
         * @param {number} partyId 
         * @param {CommentCreateRequest} commentCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createComment(partyId: number, commentCreateRequest: CommentCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponseVoid> {
            return localVarFp.createComment(partyId, commentCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 맛집 탐험 파티 모집 게시글을 작성합니다.(Completed)
         * @summary 파티 생성
         * @param {PartyCreateRequest} partyCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createParty(partyCreateRequest: PartyCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponseVoid> {
            return localVarFp.createParty(partyCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * shopId에 해당하는 식당에 예약을 생성한다. 파티 예약인 경우 partyId를 쿼리 파라미터로 전달해야 한다.(Completed)
         * @summary 예약 생성
         * @param {number} shopId 
         * @param {CreateReservationRequest} createReservationRequest 
         * @param {number} [partyId] 파티 ID (선택값). 파티 예약일 경우 전달.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReservation(shopId: number, createReservationRequest: CreateReservationRequest, partyId?: number, options?: RawAxiosRequestConfig): AxiosPromise<CreateReservationResponse> {
            return localVarFp.createReservation(shopId, createReservationRequest, partyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 리뷰를 작성합니다.(Completed)
         * @summary 리뷰 작성
         * @param {ReviewCreateRequest} reviewCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReview(reviewCreateRequest: ReviewCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponsePreSignedUrlListResponse> {
            return localVarFp.createReview(reviewCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 새로운 식당을 생성합니다.(Completed)
         * @summary 식당 생성
         * @param {ShopCreateRequest} shopCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShop(shopCreateRequest: ShopCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponsePreSignedUrlListResponse> {
            return localVarFp.createShop(shopCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 특정 댓글을 삭제합니다.(Completed)
         * @summary 댓글 삭제
         * @param {number} commentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteComment(commentId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteComment(commentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 맛집 탐험 파티 게시글을 삭제합니다.(Completed)
         * @summary 파티 삭제
         * @param {number} partyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteParty(partyId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteParty(partyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 프로필 수정 작업 중 예외 발생으로 업로드된 이미지를 삭제합니다.(Completed)
         * @summary 프로필 이미지 삭제
         * @param {DeleteProfileRequest} deleteProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProfile(deleteProfileRequest: DeleteProfileRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteProfile(deleteProfileRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 특정 리뷰를 삭제합니다.(Completed)
         * @summary 리뷰 삭제
         * @param {number} reviewId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReview(reviewId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteReview(reviewId, options).then((request) => request(axios, basePath));
        },
        /**
         * 회원 탈퇴 기능(Inprogress)
         * @summary 회원탈퇴
         * @param {string} refreshToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(refreshToken: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteUser(refreshToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 특정 모임의 댓글 목록을 조회합니다.(Completed)
         * @summary 댓글 조회
         * @param {number} partyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComments(partyId: number, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponseListCommentResponse> {
            return localVarFp.getComments(partyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 특정 식당의 상세 정보를 조회합니다. (Completed)
         * @summary 식당 상세 조회
         * @param {number} shopId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDetailShop(shopId: number, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponseShopDetailResponse> {
            return localVarFp.getDetailShop(shopId, options).then((request) => request(axios, basePath));
        },
        /**
         * 특정 식당의 상세 정보를 조회합니다. (Completed)
         * @summary 사장의 식당 상세 조회
         * @param {number} shopId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDetailShopOwner(shopId: number, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponseShopOwnerDetailResponse> {
            return localVarFp.getDetailShopOwner(shopId, options).then((request) => request(axios, basePath));
        },
        /**
         * 로그인한 사용자의 마이페이지 정보를 조회합니다.(Completed)
         * @summary 내 정보 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyInfo(options?: RawAxiosRequestConfig): AxiosPromise<BaseResponseMyInfoResponse> {
            return localVarFp.getMyInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 로그인한 사용자의 파티 목록을 커서 기반 페이징 방식으로 조회합니다.(Completed)
         * @summary 내 파티 정보 조회
         * @param {number} [size] 
         * @param {number} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyParties(size?: number, cursor?: number, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponseMyPartyPageResponse> {
            return localVarFp.getMyParties(size, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * 로그인한 사용자의 예약 목록을 커서 기반 페이징 방식으로 조회합니다.(Completed)
         * @summary 내 예약 정보 조회
         * @param {number} [size] 
         * @param {number} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyReservations(size?: number, cursor?: number, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponseMyReservationPageResponse> {
            return localVarFp.getMyReservations(size, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * 로그인한 사용자가 작성한 리뷰 목록을 커서 기반 페이징 방식으로 조회합니다.(Completed)
         * @summary 내 리뷰 정보 조회
         * @param {number} [size] 
         * @param {number} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyReviews(size?: number, cursor?: number, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponseMyReviewPageResponse> {
            return localVarFp.getMyReviews(size, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * 사장 한명이 가진 식당들 리스트들을 조회합니다.(Completed)
         * @summary 사장이 가진 식당들 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOwnerShops(options?: RawAxiosRequestConfig): AxiosPromise<BaseResponseOwnerShopsList> {
            return localVarFp.getOwnerShops(options).then((request) => request(axios, basePath));
        },
        /**
         * 파티 상태, 위치, 음식 카테고리로 필터링한 파티 게시글 목록을 조회합니다. (Completed)  예시 /parties?status=RECRUITING&minAge=10&categories=CHICKEN&categories=JAPANESE  | 필드 명     | 자료형    | 필수 여부  | 설명                                            | 기본값                   | |------------|---------|-----------|-------------------------------------------------|------------------------| | status     | string  | Optional  | 파티 상태                                        | 전체                    | | gender     | string  | Optional  | 모집 성별 조건(A일 시 성별 무관인 파티만 조회합니다.)   |  전체                   | | minAge     | int     | Optional  | 모집 최소 나이                                    | 전체                    | | maxAge     | int     | Optional  | 모집 최대 나이                                    | 전체                    | | location   | string  | Optional  | 시/도 단위 파티 위치                               | 전체                    | | category   | string  | Optional  | 음식 카테고리 (다중 선택 가능)                       | 전체                    | | query      | string  | Optional  | 파티 제목 검색 키워드                               | 전체                    | | cursor       | int  | Optional   | 페이징 마지막 파티 id                               | 첫번째 페이지            | 
         * @summary 파티 목록 조회
         * @param {GetPartiesStatusEnum} [status] 
         * @param {GetPartiesGenderEnum} [gender] 
         * @param {number} [minAge] 
         * @param {number} [maxAge] 
         * @param {string} [location] 
         * @param {Array<GetPartiesCategoriesEnum>} [categories] 
         * @param {string} [query] 
         * @param {number} [cursor] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParties(status?: GetPartiesStatusEnum, gender?: GetPartiesGenderEnum, minAge?: number, maxAge?: number, location?: string, categories?: Array<GetPartiesCategoriesEnum>, query?: string, cursor?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponsePartyScrollResponse> {
            return localVarFp.getParties(status, gender, minAge, maxAge, location, categories, query, cursor, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 맛집 탐험 파티 게시글 상세 정보를 조회합니다.(Completed)
         * @summary 파티 상세 조회
         * @param {number} partyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartyDetail(partyId: number, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponsePartyDetailResponse> {
            return localVarFp.getPartyDetail(partyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 내 정보 수정 항목 중 프로필 이미지를 업로드하기 위한 pre-signed url을 생성합니다.(Completed)
         * @summary 프로필 이미지 업로드를 위한 pre-signed url 생성
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfilePresignedUrl(options?: RawAxiosRequestConfig): AxiosPromise<BaseResponsePreSignedUrlResponse> {
            return localVarFp.getProfilePresignedUrl(options).then((request) => request(axios, basePath));
        },
        /**
         * 식당의 예약 목록을 필터와 커서 기반으로 조회한다.(Completed)
         * @summary 식당 예약 목록 조회
         * @param {GetReservationsFilterEnum} [filter] 
         * @param {number} [cursor] 
         * @param {number} [size] 
         * @param {number} [shopId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReservations(filter?: GetReservationsFilterEnum, cursor?: number, size?: number, shopId?: number, options?: RawAxiosRequestConfig): AxiosPromise<ReservationListResponse> {
            return localVarFp.getReservations(filter, cursor, size, shopId, options).then((request) => request(axios, basePath));
        },
        /**
         * 특정 가게의 리뷰 목록을 조회합니다.(Completed)
         * @summary 리뷰 조회
         * @param {number} shopId 
         * @param {number} [cursor] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReviews(shopId: number, cursor?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponseReviewPageResponse> {
            return localVarFp.getReviews(shopId, cursor, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 위치 기반으로 식당 목록을 조회합니다. (Completed)  반경은 m 단위로 주시면 되며 ->  3km (3000) 만약 사용자가 자신의 위치를 허용한다면 latitude과 longitude에 사용자 위도 경도, 원하는 범위를 넣어서 요청을 보내고 그렇지 않는다면 기본값으론 종로구 좌표에 3km 범위 식당을 가져옵니다  예시 /shops?radius=1000000&sort=rating  | 필드 명     | 자료형  | 필수 여부 | 설명                   | 기본값           | |------------|---------|-----------|-------------------------|------------------| | latitude   | double  | Required  | 사용자 위치의 위도         | 37.5724          | | longitude  | double  | Required  | 사용자 위치의 경도         | 126.9794         | | radius     | double  | Optional  | 검색 반경 (단위: m)       | 3000.0           | | category   | string  | Optional  | 음식 카테고리             | 전체             | | sort       | string  | Optional  | 정렬 기준 (근처순, 평점순) | 근처 순(distance) |  
         * @summary 식당 목록 조회
         * @param {number} [latitude] 
         * @param {number} [longitude] 
         * @param {number} [radius] 
         * @param {Array<GetShopsCategoryEnum>} [category] 
         * @param {string} [sort] 
         * @param {number} [cursor] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShops(latitude?: number, longitude?: number, radius?: number, category?: Array<GetShopsCategoryEnum>, sort?: string, cursor?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponseShopsResponse> {
            return localVarFp.getShops(latitude, longitude, radius, category, sort, cursor, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 키워드로 식당을 검색합니다.정렬기준: NAME, CREATED_AT, RATING  (Completed)
         * @summary 식당 검색
         * @param {string} [query] 
         * @param {GetShopsBySearchSortEnum} [sort] 
         * @param {string} [cursor] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShopsBySearch(query?: string, sort?: GetShopsBySearchSortEnum, cursor?: string, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponseShopPageResponse> {
            return localVarFp.getShopsBySearch(query, sort, cursor, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 맛집 탐험 파티를 참여합니다.(Completed)
         * @summary 파티 참여
         * @param {number} partyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinParty(partyId: number, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponseVoid> {
            return localVarFp.joinParty(partyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 폼 로그인으로 로그인합니다. 성공 시 액세스 토큰은 헤더, 리프레시 토큰은 쿠키에 포함됩니다.(Completed)
         * @summary Form 로그인
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponseVoid> {
            return localVarFp.login(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 쿠키의 리프레시 토큰을 무효화하고 로그아웃 처리합니다.
         * @summary 로그아웃
         * @param {string} refreshToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(refreshToken: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.logout(refreshToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 프론트는 이 URL로 리디렉션하여 OAuth2 로그인을 시작합니다. 예: /oauth2/authorization/google
         * @summary OAuth2 로그인 진입점 URL 안내
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauth2Urls(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: string; }> {
            return localVarFp.oauth2Urls(options).then((request) => request(axios, basePath));
        },
        /**
         * OAuth 추가 회원가입(Completed)
         * @summary 회원가입
         * @param {OAuthSignUpRequest} oAuthSignUpRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthSignup(oAuthSignUpRequest: OAuthSignUpRequest, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponseVoid> {
            return localVarFp.oauthSignup(oAuthSignUpRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ownerTest(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.ownerTest(options).then((request) => request(axios, basePath));
        },
        /**
         * 맛집 탐험 파티를 참여를 취소합니다.(Completed)
         * @summary 파티 탈퇴
         * @param {number} partyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quitParty(partyId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.quitParty(partyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 쿠키의 리프레시 토큰을 이용해 새로운 액세스 토큰을 재발급합니다.
         * @summary 액세스 토큰 재발급
         * @param {string} refreshToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken(refreshToken: string, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponseAccessTokenResponseDto> {
            return localVarFp.refreshToken(refreshToken, options).then((request) => request(axios, basePath));
        },
        /**
         * reservationId에 해당하는 예약을 CANCELLED 상태로 변경한다. (Completed)
         * @summary 예약 거절
         * @param {number} reservationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refuseReservation(reservationId: number, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponseVoid> {
            return localVarFp.refuseReservation(reservationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 폼 로그인 회원가입(Completed)
         * @summary 회원가입
         * @param {SignUpRequest} signUpRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signup(signUpRequest: SignUpRequest, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponseVoid> {
            return localVarFp.signup(signUpRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 로그인한 사용자의 마이페이지 정보를 수정합니다.(Completed)
         * @summary 내 정보 수정
         * @param {MyInfoUpdateRequest} myInfoUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMyInfo(myInfoUpdateRequest: MyInfoUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponseVoid> {
            return localVarFp.updateMyInfo(myInfoUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 식당 정보를 수정합니다. (Completed)
         * @summary 사장 식당 정보 수정
         * @param {number} shopId 
         * @param {ShopUpdateRequest} shopUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShop(shopId: number, shopUpdateRequest: ShopUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponsePreSignedUrlListResponse> {
            return localVarFp.updateShop(shopId, shopUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userTest(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.userTest(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * APIApi - object-oriented interface
 * @export
 * @class APIApi
 * @extends {BaseAPI}
 */
export class APIApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public adminTest(options?: RawAxiosRequestConfig) {
        return APIApiFp(this.configuration).adminTest(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 모집중인 파티를 모집종료 상태로 변경합니다.(Completed)
     * @summary 파티 모집 완료 상태 변경
     * @param {number} partyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public completeParty(partyId: number, options?: RawAxiosRequestConfig) {
        return APIApiFp(this.configuration).completeParty(partyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * TOSS_SECRET_KEY=test_gsk_docs_OaPz8L5KdmQXkzRz3y47BMw6 TOSS_CLIENT_KEY=test_gck_docs_Ovk5rk1EwkEbP0W43n07xlzm 혹여나 프론트와 토스페이 api 통신이 되지 않으면  https://github.com/prgrms-be-devcourse/NBE5-7-2-Team09  링크에 프론트 코드 링크 참조해주세요
     * @summary Confirm
     * @param {TossPaymentConfirmRequest} tossPaymentConfirmRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public confirm(tossPaymentConfirmRequest: TossPaymentConfirmRequest, options?: RawAxiosRequestConfig) {
        return APIApiFp(this.configuration).confirm(tossPaymentConfirmRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * reservationId에 해당하는 예약을 CONFIRMED 상태로 변경한다. (Completed)
     * @summary 예약 수락
     * @param {number} reservationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public confirmReservation(reservationId: number, options?: RawAxiosRequestConfig) {
        return APIApiFp(this.configuration).confirmReservation(reservationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 특정 모임에 댓글을 작성합니다.(Completed)
     * @summary 댓글 작성
     * @param {number} partyId 
     * @param {CommentCreateRequest} commentCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public createComment(partyId: number, commentCreateRequest: CommentCreateRequest, options?: RawAxiosRequestConfig) {
        return APIApiFp(this.configuration).createComment(partyId, commentCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 맛집 탐험 파티 모집 게시글을 작성합니다.(Completed)
     * @summary 파티 생성
     * @param {PartyCreateRequest} partyCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public createParty(partyCreateRequest: PartyCreateRequest, options?: RawAxiosRequestConfig) {
        return APIApiFp(this.configuration).createParty(partyCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * shopId에 해당하는 식당에 예약을 생성한다. 파티 예약인 경우 partyId를 쿼리 파라미터로 전달해야 한다.(Completed)
     * @summary 예약 생성
     * @param {number} shopId 
     * @param {CreateReservationRequest} createReservationRequest 
     * @param {number} [partyId] 파티 ID (선택값). 파티 예약일 경우 전달.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public createReservation(shopId: number, createReservationRequest: CreateReservationRequest, partyId?: number, options?: RawAxiosRequestConfig) {
        return APIApiFp(this.configuration).createReservation(shopId, createReservationRequest, partyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 리뷰를 작성합니다.(Completed)
     * @summary 리뷰 작성
     * @param {ReviewCreateRequest} reviewCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public createReview(reviewCreateRequest: ReviewCreateRequest, options?: RawAxiosRequestConfig) {
        return APIApiFp(this.configuration).createReview(reviewCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 새로운 식당을 생성합니다.(Completed)
     * @summary 식당 생성
     * @param {ShopCreateRequest} shopCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public createShop(shopCreateRequest: ShopCreateRequest, options?: RawAxiosRequestConfig) {
        return APIApiFp(this.configuration).createShop(shopCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 특정 댓글을 삭제합니다.(Completed)
     * @summary 댓글 삭제
     * @param {number} commentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public deleteComment(commentId: number, options?: RawAxiosRequestConfig) {
        return APIApiFp(this.configuration).deleteComment(commentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 맛집 탐험 파티 게시글을 삭제합니다.(Completed)
     * @summary 파티 삭제
     * @param {number} partyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public deleteParty(partyId: number, options?: RawAxiosRequestConfig) {
        return APIApiFp(this.configuration).deleteParty(partyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 프로필 수정 작업 중 예외 발생으로 업로드된 이미지를 삭제합니다.(Completed)
     * @summary 프로필 이미지 삭제
     * @param {DeleteProfileRequest} deleteProfileRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public deleteProfile(deleteProfileRequest: DeleteProfileRequest, options?: RawAxiosRequestConfig) {
        return APIApiFp(this.configuration).deleteProfile(deleteProfileRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 특정 리뷰를 삭제합니다.(Completed)
     * @summary 리뷰 삭제
     * @param {number} reviewId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public deleteReview(reviewId: number, options?: RawAxiosRequestConfig) {
        return APIApiFp(this.configuration).deleteReview(reviewId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 회원 탈퇴 기능(Inprogress)
     * @summary 회원탈퇴
     * @param {string} refreshToken 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public deleteUser(refreshToken: string, options?: RawAxiosRequestConfig) {
        return APIApiFp(this.configuration).deleteUser(refreshToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 특정 모임의 댓글 목록을 조회합니다.(Completed)
     * @summary 댓글 조회
     * @param {number} partyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public getComments(partyId: number, options?: RawAxiosRequestConfig) {
        return APIApiFp(this.configuration).getComments(partyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 특정 식당의 상세 정보를 조회합니다. (Completed)
     * @summary 식당 상세 조회
     * @param {number} shopId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public getDetailShop(shopId: number, options?: RawAxiosRequestConfig) {
        return APIApiFp(this.configuration).getDetailShop(shopId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 특정 식당의 상세 정보를 조회합니다. (Completed)
     * @summary 사장의 식당 상세 조회
     * @param {number} shopId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public getDetailShopOwner(shopId: number, options?: RawAxiosRequestConfig) {
        return APIApiFp(this.configuration).getDetailShopOwner(shopId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 로그인한 사용자의 마이페이지 정보를 조회합니다.(Completed)
     * @summary 내 정보 조회
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public getMyInfo(options?: RawAxiosRequestConfig) {
        return APIApiFp(this.configuration).getMyInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 로그인한 사용자의 파티 목록을 커서 기반 페이징 방식으로 조회합니다.(Completed)
     * @summary 내 파티 정보 조회
     * @param {number} [size] 
     * @param {number} [cursor] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public getMyParties(size?: number, cursor?: number, options?: RawAxiosRequestConfig) {
        return APIApiFp(this.configuration).getMyParties(size, cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 로그인한 사용자의 예약 목록을 커서 기반 페이징 방식으로 조회합니다.(Completed)
     * @summary 내 예약 정보 조회
     * @param {number} [size] 
     * @param {number} [cursor] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public getMyReservations(size?: number, cursor?: number, options?: RawAxiosRequestConfig) {
        return APIApiFp(this.configuration).getMyReservations(size, cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 로그인한 사용자가 작성한 리뷰 목록을 커서 기반 페이징 방식으로 조회합니다.(Completed)
     * @summary 내 리뷰 정보 조회
     * @param {number} [size] 
     * @param {number} [cursor] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public getMyReviews(size?: number, cursor?: number, options?: RawAxiosRequestConfig) {
        return APIApiFp(this.configuration).getMyReviews(size, cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 사장 한명이 가진 식당들 리스트들을 조회합니다.(Completed)
     * @summary 사장이 가진 식당들 조회
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public getOwnerShops(options?: RawAxiosRequestConfig) {
        return APIApiFp(this.configuration).getOwnerShops(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 파티 상태, 위치, 음식 카테고리로 필터링한 파티 게시글 목록을 조회합니다. (Completed)  예시 /parties?status=RECRUITING&minAge=10&categories=CHICKEN&categories=JAPANESE  | 필드 명     | 자료형    | 필수 여부  | 설명                                            | 기본값                   | |------------|---------|-----------|-------------------------------------------------|------------------------| | status     | string  | Optional  | 파티 상태                                        | 전체                    | | gender     | string  | Optional  | 모집 성별 조건(A일 시 성별 무관인 파티만 조회합니다.)   |  전체                   | | minAge     | int     | Optional  | 모집 최소 나이                                    | 전체                    | | maxAge     | int     | Optional  | 모집 최대 나이                                    | 전체                    | | location   | string  | Optional  | 시/도 단위 파티 위치                               | 전체                    | | category   | string  | Optional  | 음식 카테고리 (다중 선택 가능)                       | 전체                    | | query      | string  | Optional  | 파티 제목 검색 키워드                               | 전체                    | | cursor       | int  | Optional   | 페이징 마지막 파티 id                               | 첫번째 페이지            | 
     * @summary 파티 목록 조회
     * @param {GetPartiesStatusEnum} [status] 
     * @param {GetPartiesGenderEnum} [gender] 
     * @param {number} [minAge] 
     * @param {number} [maxAge] 
     * @param {string} [location] 
     * @param {Array<GetPartiesCategoriesEnum>} [categories] 
     * @param {string} [query] 
     * @param {number} [cursor] 
     * @param {number} [size] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public getParties(status?: GetPartiesStatusEnum, gender?: GetPartiesGenderEnum, minAge?: number, maxAge?: number, location?: string, categories?: Array<GetPartiesCategoriesEnum>, query?: string, cursor?: number, size?: number, options?: RawAxiosRequestConfig) {
        return APIApiFp(this.configuration).getParties(status, gender, minAge, maxAge, location, categories, query, cursor, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 맛집 탐험 파티 게시글 상세 정보를 조회합니다.(Completed)
     * @summary 파티 상세 조회
     * @param {number} partyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public getPartyDetail(partyId: number, options?: RawAxiosRequestConfig) {
        return APIApiFp(this.configuration).getPartyDetail(partyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 내 정보 수정 항목 중 프로필 이미지를 업로드하기 위한 pre-signed url을 생성합니다.(Completed)
     * @summary 프로필 이미지 업로드를 위한 pre-signed url 생성
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public getProfilePresignedUrl(options?: RawAxiosRequestConfig) {
        return APIApiFp(this.configuration).getProfilePresignedUrl(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 식당의 예약 목록을 필터와 커서 기반으로 조회한다.(Completed)
     * @summary 식당 예약 목록 조회
     * @param {GetReservationsFilterEnum} [filter] 
     * @param {number} [cursor] 
     * @param {number} [size] 
     * @param {number} [shopId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public getReservations(filter?: GetReservationsFilterEnum, cursor?: number, size?: number, shopId?: number, options?: RawAxiosRequestConfig) {
        return APIApiFp(this.configuration).getReservations(filter, cursor, size, shopId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 특정 가게의 리뷰 목록을 조회합니다.(Completed)
     * @summary 리뷰 조회
     * @param {number} shopId 
     * @param {number} [cursor] 
     * @param {number} [size] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public getReviews(shopId: number, cursor?: number, size?: number, options?: RawAxiosRequestConfig) {
        return APIApiFp(this.configuration).getReviews(shopId, cursor, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 위치 기반으로 식당 목록을 조회합니다. (Completed)  반경은 m 단위로 주시면 되며 ->  3km (3000) 만약 사용자가 자신의 위치를 허용한다면 latitude과 longitude에 사용자 위도 경도, 원하는 범위를 넣어서 요청을 보내고 그렇지 않는다면 기본값으론 종로구 좌표에 3km 범위 식당을 가져옵니다  예시 /shops?radius=1000000&sort=rating  | 필드 명     | 자료형  | 필수 여부 | 설명                   | 기본값           | |------------|---------|-----------|-------------------------|------------------| | latitude   | double  | Required  | 사용자 위치의 위도         | 37.5724          | | longitude  | double  | Required  | 사용자 위치의 경도         | 126.9794         | | radius     | double  | Optional  | 검색 반경 (단위: m)       | 3000.0           | | category   | string  | Optional  | 음식 카테고리             | 전체             | | sort       | string  | Optional  | 정렬 기준 (근처순, 평점순) | 근처 순(distance) |  
     * @summary 식당 목록 조회
     * @param {number} [latitude] 
     * @param {number} [longitude] 
     * @param {number} [radius] 
     * @param {Array<GetShopsCategoryEnum>} [category] 
     * @param {string} [sort] 
     * @param {number} [cursor] 
     * @param {number} [size] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public getShops(latitude?: number, longitude?: number, radius?: number, category?: Array<GetShopsCategoryEnum>, sort?: string, cursor?: number, size?: number, options?: RawAxiosRequestConfig) {
        return APIApiFp(this.configuration).getShops(latitude, longitude, radius, category, sort, cursor, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 키워드로 식당을 검색합니다.정렬기준: NAME, CREATED_AT, RATING  (Completed)
     * @summary 식당 검색
     * @param {string} [query] 
     * @param {GetShopsBySearchSortEnum} [sort] 
     * @param {string} [cursor] 
     * @param {number} [size] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public getShopsBySearch(query?: string, sort?: GetShopsBySearchSortEnum, cursor?: string, size?: number, options?: RawAxiosRequestConfig) {
        return APIApiFp(this.configuration).getShopsBySearch(query, sort, cursor, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 맛집 탐험 파티를 참여합니다.(Completed)
     * @summary 파티 참여
     * @param {number} partyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public joinParty(partyId: number, options?: RawAxiosRequestConfig) {
        return APIApiFp(this.configuration).joinParty(partyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 폼 로그인으로 로그인합니다. 성공 시 액세스 토큰은 헤더, 리프레시 토큰은 쿠키에 포함됩니다.(Completed)
     * @summary Form 로그인
     * @param {LoginRequest} loginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public login(loginRequest: LoginRequest, options?: RawAxiosRequestConfig) {
        return APIApiFp(this.configuration).login(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 쿠키의 리프레시 토큰을 무효화하고 로그아웃 처리합니다.
     * @summary 로그아웃
     * @param {string} refreshToken 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public logout(refreshToken: string, options?: RawAxiosRequestConfig) {
        return APIApiFp(this.configuration).logout(refreshToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 프론트는 이 URL로 리디렉션하여 OAuth2 로그인을 시작합니다. 예: /oauth2/authorization/google
     * @summary OAuth2 로그인 진입점 URL 안내
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public oauth2Urls(options?: RawAxiosRequestConfig) {
        return APIApiFp(this.configuration).oauth2Urls(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * OAuth 추가 회원가입(Completed)
     * @summary 회원가입
     * @param {OAuthSignUpRequest} oAuthSignUpRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public oauthSignup(oAuthSignUpRequest: OAuthSignUpRequest, options?: RawAxiosRequestConfig) {
        return APIApiFp(this.configuration).oauthSignup(oAuthSignUpRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public ownerTest(options?: RawAxiosRequestConfig) {
        return APIApiFp(this.configuration).ownerTest(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 맛집 탐험 파티를 참여를 취소합니다.(Completed)
     * @summary 파티 탈퇴
     * @param {number} partyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public quitParty(partyId: number, options?: RawAxiosRequestConfig) {
        return APIApiFp(this.configuration).quitParty(partyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 쿠키의 리프레시 토큰을 이용해 새로운 액세스 토큰을 재발급합니다.
     * @summary 액세스 토큰 재발급
     * @param {string} refreshToken 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public refreshToken(refreshToken: string, options?: RawAxiosRequestConfig) {
        return APIApiFp(this.configuration).refreshToken(refreshToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * reservationId에 해당하는 예약을 CANCELLED 상태로 변경한다. (Completed)
     * @summary 예약 거절
     * @param {number} reservationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public refuseReservation(reservationId: number, options?: RawAxiosRequestConfig) {
        return APIApiFp(this.configuration).refuseReservation(reservationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 폼 로그인 회원가입(Completed)
     * @summary 회원가입
     * @param {SignUpRequest} signUpRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public signup(signUpRequest: SignUpRequest, options?: RawAxiosRequestConfig) {
        return APIApiFp(this.configuration).signup(signUpRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 로그인한 사용자의 마이페이지 정보를 수정합니다.(Completed)
     * @summary 내 정보 수정
     * @param {MyInfoUpdateRequest} myInfoUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public updateMyInfo(myInfoUpdateRequest: MyInfoUpdateRequest, options?: RawAxiosRequestConfig) {
        return APIApiFp(this.configuration).updateMyInfo(myInfoUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 식당 정보를 수정합니다. (Completed)
     * @summary 사장 식당 정보 수정
     * @param {number} shopId 
     * @param {ShopUpdateRequest} shopUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public updateShop(shopId: number, shopUpdateRequest: ShopUpdateRequest, options?: RawAxiosRequestConfig) {
        return APIApiFp(this.configuration).updateShop(shopId, shopUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public userTest(options?: RawAxiosRequestConfig) {
        return APIApiFp(this.configuration).userTest(options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetPartiesStatusEnum = {
    Recruiting: 'RECRUITING',
    Completed: 'COMPLETED',
    Terminated: 'TERMINATED'
} as const;
export type GetPartiesStatusEnum = typeof GetPartiesStatusEnum[keyof typeof GetPartiesStatusEnum];
/**
 * @export
 */
export const GetPartiesGenderEnum = {
    M: 'M',
    W: 'W',
    A: 'A'
} as const;
export type GetPartiesGenderEnum = typeof GetPartiesGenderEnum[keyof typeof GetPartiesGenderEnum];
/**
 * @export
 */
export const GetPartiesCategoriesEnum = {
    Chicken: 'CHICKEN',
    Chinese: 'CHINESE',
    Japanese: 'JAPANESE',
    Pizza: 'PIZZA',
    Fastfood: 'FASTFOOD',
    StewSoup: 'STEW_SOUP',
    JokBo: 'JOK_BO',
    Korean: 'KOREAN',
    Snack: 'SNACK',
    Western: 'WESTERN',
    Dessert: 'DESSERT'
} as const;
export type GetPartiesCategoriesEnum = typeof GetPartiesCategoriesEnum[keyof typeof GetPartiesCategoriesEnum];
/**
 * @export
 */
export const GetReservationsFilterEnum = {
    Pending: 'PENDING',
    Cancelled: 'CANCELLED',
    Confirmed: 'CONFIRMED',
    Refused: 'REFUSED',
    Terminated: 'TERMINATED'
} as const;
export type GetReservationsFilterEnum = typeof GetReservationsFilterEnum[keyof typeof GetReservationsFilterEnum];
/**
 * @export
 */
export const GetShopsCategoryEnum = {
    Chicken: 'CHICKEN',
    Chinese: 'CHINESE',
    Japanese: 'JAPANESE',
    Pizza: 'PIZZA',
    Fastfood: 'FASTFOOD',
    StewSoup: 'STEW_SOUP',
    JokBo: 'JOK_BO',
    Korean: 'KOREAN',
    Snack: 'SNACK',
    Western: 'WESTERN',
    Dessert: 'DESSERT'
} as const;
export type GetShopsCategoryEnum = typeof GetShopsCategoryEnum[keyof typeof GetShopsCategoryEnum];
/**
 * @export
 */
export const GetShopsBySearchSortEnum = {
    Rating: 'RATING',
    CreatedAt: 'CREATED_AT',
    Name: 'NAME'
} as const;
export type GetShopsBySearchSortEnum = typeof GetShopsBySearchSortEnum[keyof typeof GetShopsBySearchSortEnum];


