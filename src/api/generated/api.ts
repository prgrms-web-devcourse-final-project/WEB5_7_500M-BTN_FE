/* tslint:disable */
/* eslint-disable */
/**
 * 맛잘알 API
 * 엑세스 토큰은 발급 후 헤더에 들어가고 리프래쉬 토큰은 HTTP ONLY 쿠키에 들어갑니다
 *
 * The version of the OpenAPI document: v1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from "./configuration";
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from "axios";
import globalAxios from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "./common";
import type { RequestArgs } from "./base";
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  BaseAPI,
  RequiredError,
  operationServerMap,
} from "./base";

/**
 *
 * @export
 * @interface AccessTokenResponseDto
 */
export interface AccessTokenResponseDto {
  /**
   *
   * @type {string}
   * @memberof AccessTokenResponseDto
   */
  accessToken?: string;
}
/**
 *
 * @export
 * @interface ApproveRequest
 */
export interface ApproveRequest {
  /**
   *
   * @type {string}
   * @memberof ApproveRequest
   */
  approve: ApproveRequestApproveEnum;
}

export const ApproveRequestApproveEnum = {
  Pending: "PENDING",
  Approved: "APPROVED",
  Rejected: "REJECTED",
} as const;

export type ApproveRequestApproveEnum =
  (typeof ApproveRequestApproveEnum)[keyof typeof ApproveRequestApproveEnum];

/**
 *
 * @export
 * @interface BaseResponseAccessTokenResponseDto
 */
export interface BaseResponseAccessTokenResponseDto {
  /**
   *
   * @type {string}
   * @memberof BaseResponseAccessTokenResponseDto
   */
  status?: BaseResponseAccessTokenResponseDtoStatusEnum;
  /**
   *
   * @type {AccessTokenResponseDto}
   * @memberof BaseResponseAccessTokenResponseDto
   */
  data?: AccessTokenResponseDto;
}

export const BaseResponseAccessTokenResponseDtoStatusEnum = {
  Ok: "OK",
  Created: "CREATED",
} as const;

export type BaseResponseAccessTokenResponseDtoStatusEnum =
  (typeof BaseResponseAccessTokenResponseDtoStatusEnum)[keyof typeof BaseResponseAccessTokenResponseDtoStatusEnum];

/**
 *
 * @export
 * @interface BaseResponseChatMessagePageResponse
 */
export interface BaseResponseChatMessagePageResponse {
  /**
   *
   * @type {string}
   * @memberof BaseResponseChatMessagePageResponse
   */
  status?: BaseResponseChatMessagePageResponseStatusEnum;
  /**
   *
   * @type {ChatMessagePageResponse}
   * @memberof BaseResponseChatMessagePageResponse
   */
  data?: ChatMessagePageResponse;
}

export const BaseResponseChatMessagePageResponseStatusEnum = {
  Ok: "OK",
  Created: "CREATED",
} as const;

export type BaseResponseChatMessagePageResponseStatusEnum =
  (typeof BaseResponseChatMessagePageResponseStatusEnum)[keyof typeof BaseResponseChatMessagePageResponseStatusEnum];

/**
 *
 * @export
 * @interface BaseResponseGetAllPendingShopListResponse
 */
export interface BaseResponseGetAllPendingShopListResponse {
  /**
   *
   * @type {string}
   * @memberof BaseResponseGetAllPendingShopListResponse
   */
  status?: BaseResponseGetAllPendingShopListResponseStatusEnum;
  /**
   *
   * @type {GetAllPendingShopListResponse}
   * @memberof BaseResponseGetAllPendingShopListResponse
   */
  data?: GetAllPendingShopListResponse;
}

export const BaseResponseGetAllPendingShopListResponseStatusEnum = {
  Ok: "OK",
  Created: "CREATED",
} as const;

export type BaseResponseGetAllPendingShopListResponseStatusEnum =
  (typeof BaseResponseGetAllPendingShopListResponseStatusEnum)[keyof typeof BaseResponseGetAllPendingShopListResponseStatusEnum];

/**
 *
 * @export
 * @interface BaseResponseInquiryAllGetResponse
 */
export interface BaseResponseInquiryAllGetResponse {
  /**
   *
   * @type {string}
   * @memberof BaseResponseInquiryAllGetResponse
   */
  status?: BaseResponseInquiryAllGetResponseStatusEnum;
  /**
   *
   * @type {InquiryAllGetResponse}
   * @memberof BaseResponseInquiryAllGetResponse
   */
  data?: InquiryAllGetResponse;
}

export const BaseResponseInquiryAllGetResponseStatusEnum = {
  Ok: "OK",
  Created: "CREATED",
} as const;

export type BaseResponseInquiryAllGetResponseStatusEnum =
  (typeof BaseResponseInquiryAllGetResponseStatusEnum)[keyof typeof BaseResponseInquiryAllGetResponseStatusEnum];

/**
 *
 * @export
 * @interface BaseResponseInquiryOneGetResponse
 */
export interface BaseResponseInquiryOneGetResponse {
  /**
   *
   * @type {string}
   * @memberof BaseResponseInquiryOneGetResponse
   */
  status?: BaseResponseInquiryOneGetResponseStatusEnum;
  /**
   *
   * @type {InquiryOneGetResponse}
   * @memberof BaseResponseInquiryOneGetResponse
   */
  data?: InquiryOneGetResponse;
}

export const BaseResponseInquiryOneGetResponseStatusEnum = {
  Ok: "OK",
  Created: "CREATED",
} as const;

export type BaseResponseInquiryOneGetResponseStatusEnum =
  (typeof BaseResponseInquiryOneGetResponseStatusEnum)[keyof typeof BaseResponseInquiryOneGetResponseStatusEnum];

/**
 *
 * @export
 * @interface BaseResponseListChatMessageResponse
 */
export interface BaseResponseListChatMessageResponse {
  /**
   *
   * @type {string}
   * @memberof BaseResponseListChatMessageResponse
   */
  status?: BaseResponseListChatMessageResponseStatusEnum;
  /**
   *
   * @type {Array<ChatMessageResponse>}
   * @memberof BaseResponseListChatMessageResponse
   */
  data?: Array<ChatMessageResponse>;
}

export const BaseResponseListChatMessageResponseStatusEnum = {
  Ok: "OK",
  Created: "CREATED",
} as const;

export type BaseResponseListChatMessageResponseStatusEnum =
  (typeof BaseResponseListChatMessageResponseStatusEnum)[keyof typeof BaseResponseListChatMessageResponseStatusEnum];

/**
 *
 * @export
 * @interface BaseResponseListCommentResponse
 */
export interface BaseResponseListCommentResponse {
  /**
   *
   * @type {string}
   * @memberof BaseResponseListCommentResponse
   */
  status?: BaseResponseListCommentResponseStatusEnum;
  /**
   *
   * @type {Array<CommentResponse>}
   * @memberof BaseResponseListCommentResponse
   */
  data?: Array<CommentResponse>;
}

export const BaseResponseListCommentResponseStatusEnum = {
  Ok: "OK",
  Created: "CREATED",
} as const;

export type BaseResponseListCommentResponseStatusEnum =
  (typeof BaseResponseListCommentResponseStatusEnum)[keyof typeof BaseResponseListCommentResponseStatusEnum];

/**
 *
 * @export
 * @interface BaseResponseListPartyMemberResponse
 */
export interface BaseResponseListPartyMemberResponse {
  /**
   *
   * @type {string}
   * @memberof BaseResponseListPartyMemberResponse
   */
  status?: BaseResponseListPartyMemberResponseStatusEnum;
  /**
   *
   * @type {Array<PartyMemberResponse>}
   * @memberof BaseResponseListPartyMemberResponse
   */
  data?: Array<PartyMemberResponse>;
}

export const BaseResponseListPartyMemberResponseStatusEnum = {
  Ok: "OK",
  Created: "CREATED",
} as const;

export type BaseResponseListPartyMemberResponseStatusEnum =
  (typeof BaseResponseListPartyMemberResponseStatusEnum)[keyof typeof BaseResponseListPartyMemberResponseStatusEnum];

/**
 *
 * @export
 * @interface BaseResponseMyInfoResponse
 */
export interface BaseResponseMyInfoResponse {
  /**
   *
   * @type {string}
   * @memberof BaseResponseMyInfoResponse
   */
  status?: BaseResponseMyInfoResponseStatusEnum;
  /**
   *
   * @type {MyInfoResponse}
   * @memberof BaseResponseMyInfoResponse
   */
  data?: MyInfoResponse;
}

export const BaseResponseMyInfoResponseStatusEnum = {
  Ok: "OK",
  Created: "CREATED",
} as const;

export type BaseResponseMyInfoResponseStatusEnum =
  (typeof BaseResponseMyInfoResponseStatusEnum)[keyof typeof BaseResponseMyInfoResponseStatusEnum];

/**
 *
 * @export
 * @interface BaseResponseMyPartyPageResponse
 */
export interface BaseResponseMyPartyPageResponse {
  /**
   *
   * @type {string}
   * @memberof BaseResponseMyPartyPageResponse
   */
  status?: BaseResponseMyPartyPageResponseStatusEnum;
  /**
   *
   * @type {MyPartyPageResponse}
   * @memberof BaseResponseMyPartyPageResponse
   */
  data?: MyPartyPageResponse;
}

export const BaseResponseMyPartyPageResponseStatusEnum = {
  Ok: "OK",
  Created: "CREATED",
} as const;

export type BaseResponseMyPartyPageResponseStatusEnum =
  (typeof BaseResponseMyPartyPageResponseStatusEnum)[keyof typeof BaseResponseMyPartyPageResponseStatusEnum];

/**
 *
 * @export
 * @interface BaseResponseMyReservationPageResponse
 */
export interface BaseResponseMyReservationPageResponse {
  /**
   *
   * @type {string}
   * @memberof BaseResponseMyReservationPageResponse
   */
  status?: BaseResponseMyReservationPageResponseStatusEnum;
  /**
   *
   * @type {MyReservationPageResponse}
   * @memberof BaseResponseMyReservationPageResponse
   */
  data?: MyReservationPageResponse;
}

export const BaseResponseMyReservationPageResponseStatusEnum = {
  Ok: "OK",
  Created: "CREATED",
} as const;

export type BaseResponseMyReservationPageResponseStatusEnum =
  (typeof BaseResponseMyReservationPageResponseStatusEnum)[keyof typeof BaseResponseMyReservationPageResponseStatusEnum];

/**
 *
 * @export
 * @interface BaseResponseMyReviewPageResponse
 */
export interface BaseResponseMyReviewPageResponse {
  /**
   *
   * @type {string}
   * @memberof BaseResponseMyReviewPageResponse
   */
  status?: BaseResponseMyReviewPageResponseStatusEnum;
  /**
   *
   * @type {MyReviewPageResponse}
   * @memberof BaseResponseMyReviewPageResponse
   */
  data?: MyReviewPageResponse;
}

export const BaseResponseMyReviewPageResponseStatusEnum = {
  Ok: "OK",
  Created: "CREATED",
} as const;

export type BaseResponseMyReviewPageResponseStatusEnum =
  (typeof BaseResponseMyReviewPageResponseStatusEnum)[keyof typeof BaseResponseMyReviewPageResponseStatusEnum];

/**
 *
 * @export
 * @interface BaseResponseOwnerShopsList
 */
export interface BaseResponseOwnerShopsList {
  /**
   *
   * @type {string}
   * @memberof BaseResponseOwnerShopsList
   */
  status?: BaseResponseOwnerShopsListStatusEnum;
  /**
   *
   * @type {OwnerShopsList}
   * @memberof BaseResponseOwnerShopsList
   */
  data?: OwnerShopsList;
}

export const BaseResponseOwnerShopsListStatusEnum = {
  Ok: "OK",
  Created: "CREATED",
} as const;

export type BaseResponseOwnerShopsListStatusEnum =
  (typeof BaseResponseOwnerShopsListStatusEnum)[keyof typeof BaseResponseOwnerShopsListStatusEnum];

/**
 *
 * @export
 * @interface BaseResponsePartyDetailResponse
 */
export interface BaseResponsePartyDetailResponse {
  /**
   *
   * @type {string}
   * @memberof BaseResponsePartyDetailResponse
   */
  status?: BaseResponsePartyDetailResponseStatusEnum;
  /**
   *
   * @type {PartyDetailResponse}
   * @memberof BaseResponsePartyDetailResponse
   */
  data?: PartyDetailResponse;
}

export const BaseResponsePartyDetailResponseStatusEnum = {
  Ok: "OK",
  Created: "CREATED",
} as const;

export type BaseResponsePartyDetailResponseStatusEnum =
  (typeof BaseResponsePartyDetailResponseStatusEnum)[keyof typeof BaseResponsePartyDetailResponseStatusEnum];

/**
 *
 * @export
 * @interface BaseResponsePartyScrollResponse
 */
export interface BaseResponsePartyScrollResponse {
  /**
   *
   * @type {string}
   * @memberof BaseResponsePartyScrollResponse
   */
  status?: BaseResponsePartyScrollResponseStatusEnum;
  /**
   *
   * @type {PartyScrollResponse}
   * @memberof BaseResponsePartyScrollResponse
   */
  data?: PartyScrollResponse;
}

export const BaseResponsePartyScrollResponseStatusEnum = {
  Ok: "OK",
  Created: "CREATED",
} as const;

export type BaseResponsePartyScrollResponseStatusEnum =
  (typeof BaseResponsePartyScrollResponseStatusEnum)[keyof typeof BaseResponsePartyScrollResponseStatusEnum];

/**
 *
 * @export
 * @interface BaseResponsePaymentScrollResponse
 */
export interface BaseResponsePaymentScrollResponse {
  /**
   *
   * @type {string}
   * @memberof BaseResponsePaymentScrollResponse
   */
  status?: BaseResponsePaymentScrollResponseStatusEnum;
  /**
   *
   * @type {PaymentScrollResponse}
   * @memberof BaseResponsePaymentScrollResponse
   */
  data?: PaymentScrollResponse;
}

export const BaseResponsePaymentScrollResponseStatusEnum = {
  Ok: "OK",
  Created: "CREATED",
} as const;

export type BaseResponsePaymentScrollResponseStatusEnum =
  (typeof BaseResponsePaymentScrollResponseStatusEnum)[keyof typeof BaseResponsePaymentScrollResponseStatusEnum];

/**
 *
 * @export
 * @interface BaseResponsePaymentSuccessResponse
 */
export interface BaseResponsePaymentSuccessResponse {
  /**
   *
   * @type {string}
   * @memberof BaseResponsePaymentSuccessResponse
   */
  status?: BaseResponsePaymentSuccessResponseStatusEnum;
  /**
   *
   * @type {PaymentSuccessResponse}
   * @memberof BaseResponsePaymentSuccessResponse
   */
  data?: PaymentSuccessResponse;
}

export const BaseResponsePaymentSuccessResponseStatusEnum = {
  Ok: "OK",
  Created: "CREATED",
} as const;

export type BaseResponsePaymentSuccessResponseStatusEnum =
  (typeof BaseResponsePaymentSuccessResponseStatusEnum)[keyof typeof BaseResponsePaymentSuccessResponseStatusEnum];

/**
 *
 * @export
 * @interface BaseResponsePreSignedUrlListResponse
 */
export interface BaseResponsePreSignedUrlListResponse {
  /**
   *
   * @type {string}
   * @memberof BaseResponsePreSignedUrlListResponse
   */
  status?: BaseResponsePreSignedUrlListResponseStatusEnum;
  /**
   *
   * @type {PreSignedUrlListResponse}
   * @memberof BaseResponsePreSignedUrlListResponse
   */
  data?: PreSignedUrlListResponse;
}

export const BaseResponsePreSignedUrlListResponseStatusEnum = {
  Ok: "OK",
  Created: "CREATED",
} as const;

export type BaseResponsePreSignedUrlListResponseStatusEnum =
  (typeof BaseResponsePreSignedUrlListResponseStatusEnum)[keyof typeof BaseResponsePreSignedUrlListResponseStatusEnum];

/**
 *
 * @export
 * @interface BaseResponsePreSignedUrlResponse
 */
export interface BaseResponsePreSignedUrlResponse {
  /**
   *
   * @type {string}
   * @memberof BaseResponsePreSignedUrlResponse
   */
  status?: BaseResponsePreSignedUrlResponseStatusEnum;
  /**
   *
   * @type {PreSignedUrlResponse}
   * @memberof BaseResponsePreSignedUrlResponse
   */
  data?: PreSignedUrlResponse;
}

export const BaseResponsePreSignedUrlResponseStatusEnum = {
  Ok: "OK",
  Created: "CREATED",
} as const;

export type BaseResponsePreSignedUrlResponseStatusEnum =
  (typeof BaseResponsePreSignedUrlResponseStatusEnum)[keyof typeof BaseResponsePreSignedUrlResponseStatusEnum];

/**
 *
 * @export
 * @interface BaseResponseReservationListResponse
 */
export interface BaseResponseReservationListResponse {
  /**
   *
   * @type {string}
   * @memberof BaseResponseReservationListResponse
   */
  status?: BaseResponseReservationListResponseStatusEnum;
  /**
   *
   * @type {ReservationListResponse}
   * @memberof BaseResponseReservationListResponse
   */
  data?: ReservationListResponse;
}

export const BaseResponseReservationListResponseStatusEnum = {
  Ok: "OK",
  Created: "CREATED",
} as const;

export type BaseResponseReservationListResponseStatusEnum =
  (typeof BaseResponseReservationListResponseStatusEnum)[keyof typeof BaseResponseReservationListResponseStatusEnum];

/**
 *
 * @export
 * @interface BaseResponseReviewPageResponse
 */
export interface BaseResponseReviewPageResponse {
  /**
   *
   * @type {string}
   * @memberof BaseResponseReviewPageResponse
   */
  status?: BaseResponseReviewPageResponseStatusEnum;
  /**
   *
   * @type {ReviewPageResponse}
   * @memberof BaseResponseReviewPageResponse
   */
  data?: ReviewPageResponse;
}

export const BaseResponseReviewPageResponseStatusEnum = {
  Ok: "OK",
  Created: "CREATED",
} as const;

export type BaseResponseReviewPageResponseStatusEnum =
  (typeof BaseResponseReviewPageResponseStatusEnum)[keyof typeof BaseResponseReviewPageResponseStatusEnum];

/**
 *
 * @export
 * @interface BaseResponseShopAdminDetailResponse
 */
export interface BaseResponseShopAdminDetailResponse {
  /**
   *
   * @type {string}
   * @memberof BaseResponseShopAdminDetailResponse
   */
  status?: BaseResponseShopAdminDetailResponseStatusEnum;
  /**
   *
   * @type {ShopAdminDetailResponse}
   * @memberof BaseResponseShopAdminDetailResponse
   */
  data?: ShopAdminDetailResponse;
}

export const BaseResponseShopAdminDetailResponseStatusEnum = {
  Ok: "OK",
  Created: "CREATED",
} as const;

export type BaseResponseShopAdminDetailResponseStatusEnum =
  (typeof BaseResponseShopAdminDetailResponseStatusEnum)[keyof typeof BaseResponseShopAdminDetailResponseStatusEnum];

/**
 *
 * @export
 * @interface BaseResponseShopDetailResponse
 */
export interface BaseResponseShopDetailResponse {
  /**
   *
   * @type {string}
   * @memberof BaseResponseShopDetailResponse
   */
  status?: BaseResponseShopDetailResponseStatusEnum;
  /**
   *
   * @type {ShopDetailResponse}
   * @memberof BaseResponseShopDetailResponse
   */
  data?: ShopDetailResponse;
}

export const BaseResponseShopDetailResponseStatusEnum = {
  Ok: "OK",
  Created: "CREATED",
} as const;

export type BaseResponseShopDetailResponseStatusEnum =
  (typeof BaseResponseShopDetailResponseStatusEnum)[keyof typeof BaseResponseShopDetailResponseStatusEnum];

/**
 *
 * @export
 * @interface BaseResponseShopOwnerDetailResponse
 */
export interface BaseResponseShopOwnerDetailResponse {
  /**
   *
   * @type {string}
   * @memberof BaseResponseShopOwnerDetailResponse
   */
  status?: BaseResponseShopOwnerDetailResponseStatusEnum;
  /**
   *
   * @type {ShopOwnerDetailResponse}
   * @memberof BaseResponseShopOwnerDetailResponse
   */
  data?: ShopOwnerDetailResponse;
}

export const BaseResponseShopOwnerDetailResponseStatusEnum = {
  Ok: "OK",
  Created: "CREATED",
} as const;

export type BaseResponseShopOwnerDetailResponseStatusEnum =
  (typeof BaseResponseShopOwnerDetailResponseStatusEnum)[keyof typeof BaseResponseShopOwnerDetailResponseStatusEnum];

/**
 *
 * @export
 * @interface BaseResponseShopPageResponse
 */
export interface BaseResponseShopPageResponse {
  /**
   *
   * @type {string}
   * @memberof BaseResponseShopPageResponse
   */
  status?: BaseResponseShopPageResponseStatusEnum;
  /**
   *
   * @type {ShopPageResponse}
   * @memberof BaseResponseShopPageResponse
   */
  data?: ShopPageResponse;
}

export const BaseResponseShopPageResponseStatusEnum = {
  Ok: "OK",
  Created: "CREATED",
} as const;

export type BaseResponseShopPageResponseStatusEnum =
  (typeof BaseResponseShopPageResponseStatusEnum)[keyof typeof BaseResponseShopPageResponseStatusEnum];

/**
 *
 * @export
 * @interface BaseResponseShopsResponse
 */
export interface BaseResponseShopsResponse {
  /**
   *
   * @type {string}
   * @memberof BaseResponseShopsResponse
   */
  status?: BaseResponseShopsResponseStatusEnum;
  /**
   *
   * @type {ShopsResponse}
   * @memberof BaseResponseShopsResponse
   */
  data?: ShopsResponse;
}

export const BaseResponseShopsResponseStatusEnum = {
  Ok: "OK",
  Created: "CREATED",
} as const;

export type BaseResponseShopsResponseStatusEnum =
  (typeof BaseResponseShopsResponseStatusEnum)[keyof typeof BaseResponseShopsResponseStatusEnum];

/**
 *
 * @export
 * @interface BaseResponseVoid
 */
export interface BaseResponseVoid {
  /**
   *
   * @type {string}
   * @memberof BaseResponseVoid
   */
  status?: BaseResponseVoidStatusEnum;
  /**
   *
   * @type {object}
   * @memberof BaseResponseVoid
   */
  data?: object;
}

export const BaseResponseVoidStatusEnum = {
  Ok: "OK",
  Created: "CREATED",
} as const;

export type BaseResponseVoidStatusEnum =
  (typeof BaseResponseVoidStatusEnum)[keyof typeof BaseResponseVoidStatusEnum];

/**
 *
 * @export
 * @interface ChatMessagePageResponse
 */
export interface ChatMessagePageResponse {
  /**
   *
   * @type {number}
   * @memberof ChatMessagePageResponse
   */
  nextCursor?: number;
  /**
   *
   * @type {Array<ChatMessageResponse>}
   * @memberof ChatMessagePageResponse
   */
  content?: Array<ChatMessageResponse>;
}
/**
 *
 * @export
 * @interface ChatMessageResponse
 */
export interface ChatMessageResponse {
  /**
   *
   * @type {number}
   * @memberof ChatMessageResponse
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof ChatMessageResponse
   */
  sendAt?: string;
  /**
   *
   * @type {string}
   * @memberof ChatMessageResponse
   */
  type?: ChatMessageResponseTypeEnum;
  /**
   *
   * @type {string}
   * @memberof ChatMessageResponse
   */
  message?: string;
  /**
   *
   * @type {number}
   * @memberof ChatMessageResponse
   */
  userId?: number;
  /**
   *
   * @type {string}
   * @memberof ChatMessageResponse
   */
  userNickname?: string;
  /**
   *
   * @type {string}
   * @memberof ChatMessageResponse
   */
  userProfile?: string;
  /**
   *
   * @type {number}
   * @memberof ChatMessageResponse
   */
  partyId?: number;
}

export const ChatMessageResponseTypeEnum = {
  Chat: "CHAT",
  Join: "JOIN",
  Leave: "LEAVE",
  Kick: "KICK",
  Error: "ERROR",
  PaymentRequest: "PAYMENT_REQUEST",
  PaymentComplete: "PAYMENT_COMPLETE",
  PartyDeleted: "PARTY_DELETED",
  ReservationComplete: "RESERVATION_COMPLETE",
} as const;

export type ChatMessageResponseTypeEnum =
  (typeof ChatMessageResponseTypeEnum)[keyof typeof ChatMessageResponseTypeEnum];

/**
 *
 * @export
 * @interface CommentCreateRequest
 */
export interface CommentCreateRequest {
  /**
   * 부모 댓글 ID (대댓글인 경우)
   * @type {number}
   * @memberof CommentCreateRequest
   */
  parentId?: number;
  /**
   * 댓글 내용
   * @type {string}
   * @memberof CommentCreateRequest
   */
  content: string;
}
/**
 *
 * @export
 * @interface CommentResponse
 */
export interface CommentResponse {
  /**
   *
   * @type {number}
   * @memberof CommentResponse
   */
  commentId?: number;
  /**
   *
   * @type {number}
   * @memberof CommentResponse
   */
  parentId?: number;
  /**
   *
   * @type {string}
   * @memberof CommentResponse
   */
  content?: string;
  /**
   *
   * @type {string}
   * @memberof CommentResponse
   */
  createdAt?: string;
  /**
   *
   * @type {Writer}
   * @memberof CommentResponse
   */
  writer?: Writer;
}
/**
 * 예약 생성 요청 DTO
 * @export
 * @interface CreateReservationRequest
 */
export interface CreateReservationRequest {
  /**
   * 예약 날짜 (yyyy-MM-dd 형식)
   * @type {string}
   * @memberof CreateReservationRequest
   */
  date: string;
  /**
   * 예약 시간 (HH:mm 형식)
   * @type {string}
   * @memberof CreateReservationRequest
   */
  time: string;
  /**
   * 예약 인원 수
   * @type {number}
   * @memberof CreateReservationRequest
   */
  headCount?: number;
  /**
   * 예약금 (최소 1000원)
   * @type {number}
   * @memberof CreateReservationRequest
   */
  reservationFee?: number;
}
/**
 * 예약 생성 응답 DTO
 * @export
 * @interface CreateReservationResponse
 */
export interface CreateReservationResponse {
  /**
   * 예약 ID
   * @type {number}
   * @memberof CreateReservationResponse
   */
  reservationId?: number;
  /**
   * 식당 이름
   * @type {string}
   * @memberof CreateReservationResponse
   */
  shopName?: string;
  /**
   * 예약 일시 (yyyy-MM-dd HH:mm)
   * @type {string}
   * @memberof CreateReservationResponse
   */
  dateTime?: string;
  /**
   * 예약 인원 수
   * @type {number}
   * @memberof CreateReservationResponse
   */
  headCount?: number;
  /**
   * 예약 상태
   * @type {string}
   * @memberof CreateReservationResponse
   */
  status?: CreateReservationResponseStatusEnum;
}

export const CreateReservationResponseStatusEnum = {
  Pending: "PENDING",
  Cancelled: "CANCELLED",
  Confirmed: "CONFIRMED",
  Refused: "REFUSED",
  Terminated: "TERMINATED",
} as const;

export type CreateReservationResponseStatusEnum =
  (typeof CreateReservationResponseStatusEnum)[keyof typeof CreateReservationResponseStatusEnum];

/**
 *
 * @export
 * @interface DeleteProfileRequest
 */
export interface DeleteProfileRequest {
  /**
   *
   * @type {string}
   * @memberof DeleteProfileRequest
   */
  profileKey: string;
}
/**
 *
 * @export
 * @interface GetAllPendingShopListResponse
 */
export interface GetAllPendingShopListResponse {
  /**
   *
   * @type {Array<PendingShop>}
   * @memberof GetAllPendingShopListResponse
   */
  pendingShopList?: Array<PendingShop>;
}
/**
 *
 * @export
 * @interface InquiryAllGetResponse
 */
export interface InquiryAllGetResponse {
  /**
   *
   * @type {Array<InquiryItem>}
   * @memberof InquiryAllGetResponse
   */
  content?: Array<InquiryItem>;
  /**
   *
   * @type {number}
   * @memberof InquiryAllGetResponse
   */
  nextCursor?: number;
}
/**
 *
 * @export
 * @interface InquiryCreateRequest
 */
export interface InquiryCreateRequest {
  /**
   * 문의 제목
   * @type {string}
   * @memberof InquiryCreateRequest
   */
  title: string;
  /**
   * 문의 내용
   * @type {string}
   * @memberof InquiryCreateRequest
   */
  content: string;
  /**
   * 넣으려는 사진 갯수
   * @type {number}
   * @memberof InquiryCreateRequest
   */
  imageCount: number;
}
/**
 *
 * @export
 * @interface InquiryItem
 */
export interface InquiryItem {
  /**
   *
   * @type {number}
   * @memberof InquiryItem
   */
  InquiryId?: number;
  /**
   *
   * @type {string}
   * @memberof InquiryItem
   */
  title?: string;
  /**
   *
   * @type {number}
   * @memberof InquiryItem
   */
  answerCount?: number;
  /**
   *
   * @type {string}
   * @memberof InquiryItem
   */
  createTime?: string;
}
/**
 *
 * @export
 * @interface InquiryOneGetResponse
 */
export interface InquiryOneGetResponse {
  /**
   *
   * @type {string}
   * @memberof InquiryOneGetResponse
   */
  title?: string;
  /**
   *
   * @type {string}
   * @memberof InquiryOneGetResponse
   */
  content?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof InquiryOneGetResponse
   */
  images?: Array<string>;
}
/**
 * 영업 종료 시간
 * @export
 * @interface LocalTime
 */
export interface LocalTime {
  /**
   *
   * @type {number}
   * @memberof LocalTime
   */
  hour?: number;
  /**
   *
   * @type {number}
   * @memberof LocalTime
   */
  minute?: number;
  /**
   *
   * @type {number}
   * @memberof LocalTime
   */
  second?: number;
  /**
   *
   * @type {number}
   * @memberof LocalTime
   */
  nano?: number;
}
/**
 *
 * @export
 * @interface LoginRequest
 */
export interface LoginRequest {
  /**
   *
   * @type {string}
   * @memberof LoginRequest
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof LoginRequest
   */
  password: string;
}
/**
 *
 * @export
 * @interface MyInfoResponse
 */
export interface MyInfoResponse {
  /**
   *
   * @type {number}
   * @memberof MyInfoResponse
   */
  userId?: number;
  /**
   *
   * @type {string}
   * @memberof MyInfoResponse
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof MyInfoResponse
   */
  nickname?: string;
  /**
   *
   * @type {string}
   * @memberof MyInfoResponse
   */
  role?: MyInfoResponseRoleEnum;
  /**
   *
   * @type {string}
   * @memberof MyInfoResponse
   */
  name?: string;
  /**
   *
   * @type {number}
   * @memberof MyInfoResponse
   */
  age?: number;
  /**
   * 성별: M or W
   * @type {string}
   * @memberof MyInfoResponse
   */
  gender?: MyInfoResponseGenderEnum;
  /**
   *
   * @type {number}
   * @memberof MyInfoResponse
   */
  point?: number;
  /**
   *
   * @type {string}
   * @memberof MyInfoResponse
   */
  phoneNumber?: string;
  /**
   *
   * @type {string}
   * @memberof MyInfoResponse
   */
  profile?: string;
}

export const MyInfoResponseRoleEnum = {
  Admin: "ADMIN",
  User: "USER",
  Owner: "OWNER",
  Tmp: "TMP",
} as const;

export type MyInfoResponseRoleEnum =
  (typeof MyInfoResponseRoleEnum)[keyof typeof MyInfoResponseRoleEnum];
export const MyInfoResponseGenderEnum = {
  M: "M",
  W: "W",
} as const;

export type MyInfoResponseGenderEnum =
  (typeof MyInfoResponseGenderEnum)[keyof typeof MyInfoResponseGenderEnum];

/**
 * 내 정보 수정 요청
 * @export
 * @interface MyInfoUpdateRequest
 */
export interface MyInfoUpdateRequest {
  /**
   *
   * @type {string}
   * @memberof MyInfoUpdateRequest
   */
  nickname: string;
  /**
   *
   * @type {string}
   * @memberof MyInfoUpdateRequest
   */
  phoneNumber: string;
  /**
   *
   * @type {number}
   * @memberof MyInfoUpdateRequest
   */
  age?: number;
  /**
   *
   * @type {string}
   * @memberof MyInfoUpdateRequest
   */
  profileKey: string;
}
/**
 * 내 파티 목록 응답
 * @export
 * @interface MyPartyPageResponse
 */
export interface MyPartyPageResponse {
  /**
   * 파티 목록
   * @type {Array<MyPartyResponse>}
   * @memberof MyPartyPageResponse
   */
  content?: Array<MyPartyResponse>;
  /**
   * 다음 커서 ID
   * @type {number}
   * @memberof MyPartyPageResponse
   */
  nextCursor?: number;
}
/**
 * 파티 정보 요약
 * @export
 * @interface MyPartyResponse
 */
export interface MyPartyResponse {
  /**
   * 파티 ID
   * @type {number}
   * @memberof MyPartyResponse
   */
  partyId?: number;
  /**
   * 파티 제목
   * @type {string}
   * @memberof MyPartyResponse
   */
  title?: string;
  /**
   * 가게 이름
   * @type {string}
   * @memberof MyPartyResponse
   */
  shopName?: string;
  /**
   * 만남 일시
   * @type {string}
   * @memberof MyPartyResponse
   */
  metAt?: string;
  /**
   * 모집 마감 시간
   * @type {string}
   * @memberof MyPartyResponse
   */
  deadline?: string;
  /**
   * 파티 상태
   * @type {string}
   * @memberof MyPartyResponse
   */
  status?: MyPartyResponseStatusEnum;
  /**
   * 최대 인원
   * @type {number}
   * @memberof MyPartyResponse
   */
  maxCount?: number;
  /**
   * 최소 인원
   * @type {number}
   * @memberof MyPartyResponse
   */
  minCount?: number;
  /**
   * 현재 인원
   * @type {number}
   * @memberof MyPartyResponse
   */
  currentCount?: number;
  /**
   * 성별 조건
   * @type {string}
   * @memberof MyPartyResponse
   */
  genderCondition?: MyPartyResponseGenderConditionEnum;
  /**
   * 최소 나이
   * @type {number}
   * @memberof MyPartyResponse
   */
  minAge?: number;
  /**
   * 최대 나이
   * @type {number}
   * @memberof MyPartyResponse
   */
  maxAge?: number;
  /**
   * 설명
   * @type {string}
   * @memberof MyPartyResponse
   */
  description?: string;
  /**
   * 호스트 여부 (본인이 이 파티의 파티장인지 확인)
   * @type {boolean}
   * @memberof MyPartyResponse
   */
  isHost?: boolean;
}

export const MyPartyResponseStatusEnum = {
  Recruiting: "RECRUITING",
  Completed: "COMPLETED",
  Terminated: "TERMINATED",
} as const;

export type MyPartyResponseStatusEnum =
  (typeof MyPartyResponseStatusEnum)[keyof typeof MyPartyResponseStatusEnum];
export const MyPartyResponseGenderConditionEnum = {
  M: "M",
  W: "W",
  A: "A",
} as const;

export type MyPartyResponseGenderConditionEnum =
  (typeof MyPartyResponseGenderConditionEnum)[keyof typeof MyPartyResponseGenderConditionEnum];

/**
 * 내 예약 목록 응답
 * @export
 * @interface MyReservationPageResponse
 */
export interface MyReservationPageResponse {
  /**
   * 예약 목록
   * @type {Array<MyReservationResponse>}
   * @memberof MyReservationPageResponse
   */
  content?: Array<MyReservationResponse>;
  /**
   * 다음 커서 ID
   * @type {number}
   * @memberof MyReservationPageResponse
   */
  nextCursor?: number;
}
/**
 * 예약 정보 요약
 * @export
 * @interface MyReservationResponse
 */
export interface MyReservationResponse {
  /**
   * 예약 ID
   * @type {number}
   * @memberof MyReservationResponse
   */
  reservationId?: number;
  /**
   * 가게 이름
   * @type {string}
   * @memberof MyReservationResponse
   */
  shopName?: string;
  /**
   * 예약자 이름
   * @type {string}
   * @memberof MyReservationResponse
   */
  name?: string;
  /**
   * 예약 일시
   * @type {string}
   * @memberof MyReservationResponse
   */
  reservedAt?: string;
  /**
   * 예약 인원
   * @type {number}
   * @memberof MyReservationResponse
   */
  headCount?: number;
  /**
   * 예약금
   * @type {number}
   * @memberof MyReservationResponse
   */
  reservationFee?: number;
  /**
   * 예약 상태
   * @type {string}
   * @memberof MyReservationResponse
   */
  status?: MyReservationResponseStatusEnum;
}

export const MyReservationResponseStatusEnum = {
  Pending: "PENDING",
  Cancelled: "CANCELLED",
  Confirmed: "CONFIRMED",
  Refused: "REFUSED",
  Terminated: "TERMINATED",
} as const;

export type MyReservationResponseStatusEnum =
  (typeof MyReservationResponseStatusEnum)[keyof typeof MyReservationResponseStatusEnum];

/**
 * 내 리뷰 목록 응답
 * @export
 * @interface MyReviewPageResponse
 */
export interface MyReviewPageResponse {
  /**
   * 리뷰 목록
   * @type {Array<MyReviewResponse>}
   * @memberof MyReviewPageResponse
   */
  content?: Array<MyReviewResponse>;
  /**
   * 다음 커서 ID
   * @type {number}
   * @memberof MyReviewPageResponse
   */
  nextCursor?: number;
}
/**
 * 리뷰 정보 요약
 * @export
 * @interface MyReviewResponse
 */
export interface MyReviewResponse {
  /**
   * 리뷰 ID
   * @type {number}
   * @memberof MyReviewResponse
   */
  reviewId?: number;
  /**
   * 가게 이름
   * @type {string}
   * @memberof MyReviewResponse
   */
  shopName?: string;
  /**
   * 평점
   * @type {number}
   * @memberof MyReviewResponse
   */
  rating?: number;
  /**
   * 리뷰 내용
   * @type {string}
   * @memberof MyReviewResponse
   */
  content?: string;
  /**
   * 작성일
   * @type {string}
   * @memberof MyReviewResponse
   */
  createdAt?: string;
  /**
   * 리뷰 이미지 목록
   * @type {Array<string>}
   * @memberof MyReviewResponse
   */
  images?: Array<string>;
}
/**
 *
 * @export
 * @interface OAuthSignUpRequest
 */
export interface OAuthSignUpRequest {
  /**
   *
   * @type {string}
   * @memberof OAuthSignUpRequest
   */
  nickname: string;
  /**
   *
   * @type {string}
   * @memberof OAuthSignUpRequest
   */
  phoneNumber: string;
  /**
   *
   * @type {string}
   * @memberof OAuthSignUpRequest
   */
  name: string;
  /**
   *
   * @type {number}
   * @memberof OAuthSignUpRequest
   */
  age?: number;
  /**
   *
   * @type {string}
   * @memberof OAuthSignUpRequest
   */
  gender: OAuthSignUpRequestGenderEnum;
}

export const OAuthSignUpRequestGenderEnum = {
  M: "M",
  W: "W",
} as const;

export type OAuthSignUpRequestGenderEnum =
  (typeof OAuthSignUpRequestGenderEnum)[keyof typeof OAuthSignUpRequestGenderEnum];

/**
 *
 * @export
 * @interface OrderSaveRequest
 */
export interface OrderSaveRequest {
  /**
   * 클라이언트에서 생성한 주문 id
   * @type {string}
   * @memberof OrderSaveRequest
   */
  orderId: string;
  /**
   * 결제 금액은 포인트 충전 머니입니다.. 1000원부터 1000원 단위로 50000원까지 충전 가능합니다.
   * @type {number}
   * @memberof OrderSaveRequest
   */
  amount?: number;
}
/**
 *
 * @export
 * @interface OwnerShopItem
 */
export interface OwnerShopItem {
  /**
   *
   * @type {number}
   * @memberof OwnerShopItem
   */
  shopId?: number;
  /**
   *
   * @type {string}
   * @memberof OwnerShopItem
   */
  shopName?: string;
  /**
   *
   * @type {string}
   * @memberof OwnerShopItem
   */
  category?: OwnerShopItemCategoryEnum;
  /**
   *
   * @type {string}
   * @memberof OwnerShopItem
   */
  roadAddress?: string;
  /**
   *
   * @type {string}
   * @memberof OwnerShopItem
   */
  detailAddress?: string;
  /**
   *
   * @type {number}
   * @memberof OwnerShopItem
   */
  rating?: number;
  /**
   *
   * @type {string}
   * @memberof OwnerShopItem
   */
  approve?: OwnerShopItemApproveEnum;
  /**
   *
   * @type {string}
   * @memberof OwnerShopItem
   */
  thumbnailUrl?: string;
}

export const OwnerShopItemCategoryEnum = {
  Chicken: "CHICKEN",
  Chinese: "CHINESE",
  Japanese: "JAPANESE",
  Pizza: "PIZZA",
  Fastfood: "FASTFOOD",
  StewSoup: "STEW_SOUP",
  JokBo: "JOK_BO",
  Korean: "KOREAN",
  Snack: "SNACK",
  Western: "WESTERN",
  Dessert: "DESSERT",
} as const;

export type OwnerShopItemCategoryEnum =
  (typeof OwnerShopItemCategoryEnum)[keyof typeof OwnerShopItemCategoryEnum];
export const OwnerShopItemApproveEnum = {
  Pending: "PENDING",
  Approved: "APPROVED",
  Rejected: "REJECTED",
} as const;

export type OwnerShopItemApproveEnum =
  (typeof OwnerShopItemApproveEnum)[keyof typeof OwnerShopItemApproveEnum];

/**
 *
 * @export
 * @interface OwnerShopsList
 */
export interface OwnerShopsList {
  /**
   *
   * @type {Array<OwnerShopItem>}
   * @memberof OwnerShopsList
   */
  shopItem?: Array<OwnerShopItem>;
}
/**
 *
 * @export
 * @interface PartyCreateRequest
 */
export interface PartyCreateRequest {
  /**
   * 게시글 제목
   * @type {string}
   * @memberof PartyCreateRequest
   */
  title: string;
  /**
   * 음식점 ID
   * @type {number}
   * @memberof PartyCreateRequest
   */
  shopId: number;
  /**
   * 모임 일시
   * @type {string}
   * @memberof PartyCreateRequest
   */
  metAt: string;
  /**
   * 파티 모집 마감 일시
   * @type {string}
   * @memberof PartyCreateRequest
   */
  deadline: string;
  /**
   * 모집 성별(W(여자), M(남자), A(무관) 중 택 1
   * @type {string}
   * @memberof PartyCreateRequest
   */
  genderCondition: PartyCreateRequestGenderConditionEnum;
  /**
   * 모집 최소 나이
   * @type {number}
   * @memberof PartyCreateRequest
   */
  minAge?: number;
  /**
   * 모집 최대 나이
   * @type {number}
   * @memberof PartyCreateRequest
   */
  maxAge?: number;
  /**
   * 파티 최소 인원(파티 호스트 포함)
   * @type {number}
   * @memberof PartyCreateRequest
   */
  minCount: number;
  /**
   * 파티 최대 인원(파티 호스트 포함)
   * @type {number}
   * @memberof PartyCreateRequest
   */
  maxCount: number;
  /**
   * 게시글 본문
   * @type {string}
   * @memberof PartyCreateRequest
   */
  description?: string;
}

export const PartyCreateRequestGenderConditionEnum = {
  M: "M",
  W: "W",
  A: "A",
} as const;

export type PartyCreateRequestGenderConditionEnum =
  (typeof PartyCreateRequestGenderConditionEnum)[keyof typeof PartyCreateRequestGenderConditionEnum];

/**
 *
 * @export
 * @interface PartyDetailResponse
 */
export interface PartyDetailResponse {
  /**
   *
   * @type {number}
   * @memberof PartyDetailResponse
   */
  partyId?: number;
  /**
   *
   * @type {string}
   * @memberof PartyDetailResponse
   */
  title?: string;
  /**
   *
   * @type {string}
   * @memberof PartyDetailResponse
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof PartyDetailResponse
   */
  status?: PartyDetailResponseStatusEnum;
  /**
   *
   * @type {number}
   * @memberof PartyDetailResponse
   */
  maxCount?: number;
  /**
   *
   * @type {number}
   * @memberof PartyDetailResponse
   */
  minCount?: number;
  /**
   *
   * @type {number}
   * @memberof PartyDetailResponse
   */
  currentCount?: number;
  /**
   *
   * @type {string}
   * @memberof PartyDetailResponse
   */
  genderCondition?: PartyDetailResponseGenderConditionEnum;
  /**
   *
   * @type {number}
   * @memberof PartyDetailResponse
   */
  minAge?: number;
  /**
   *
   * @type {number}
   * @memberof PartyDetailResponse
   */
  maxAge?: number;
  /**
   *
   * @type {string}
   * @memberof PartyDetailResponse
   */
  metAt?: string;
  /**
   *
   * @type {string}
   * @memberof PartyDetailResponse
   */
  deadline?: string;
  /**
   *
   * @type {string}
   * @memberof PartyDetailResponse
   */
  createdAt?: string;
  /**
   *
   * @type {number}
   * @memberof PartyDetailResponse
   */
  shopId?: number;
  /**
   *
   * @type {string}
   * @memberof PartyDetailResponse
   */
  shopName?: string;
  /**
   *
   * @type {string}
   * @memberof PartyDetailResponse
   */
  shopRoadAddress?: string;
  /**
   *
   * @type {string}
   * @memberof PartyDetailResponse
   */
  shopDetailAddress?: string;
  /**
   *
   * @type {string}
   * @memberof PartyDetailResponse
   */
  shopImage?: string;
  /**
   *
   * @type {Array<PartyMemberResponse>}
   * @memberof PartyDetailResponse
   */
  members?: Array<PartyMemberResponse>;
}

export const PartyDetailResponseStatusEnum = {
  Recruiting: "RECRUITING",
  Completed: "COMPLETED",
  Terminated: "TERMINATED",
} as const;

export type PartyDetailResponseStatusEnum =
  (typeof PartyDetailResponseStatusEnum)[keyof typeof PartyDetailResponseStatusEnum];
export const PartyDetailResponseGenderConditionEnum = {
  M: "M",
  W: "W",
  A: "A",
} as const;

export type PartyDetailResponseGenderConditionEnum =
  (typeof PartyDetailResponseGenderConditionEnum)[keyof typeof PartyDetailResponseGenderConditionEnum];

/**
 *
 * @export
 * @interface PartyListResponse
 */
export interface PartyListResponse {
  /**
   *
   * @type {number}
   * @memberof PartyListResponse
   */
  partyId?: number;
  /**
   *
   * @type {string}
   * @memberof PartyListResponse
   */
  title?: string;
  /**
   *
   * @type {string}
   * @memberof PartyListResponse
   */
  status?: PartyListResponseStatusEnum;
  /**
   *
   * @type {number}
   * @memberof PartyListResponse
   */
  maxCount?: number;
  /**
   *
   * @type {number}
   * @memberof PartyListResponse
   */
  minCount?: number;
  /**
   *
   * @type {number}
   * @memberof PartyListResponse
   */
  currentCount?: number;
  /**
   *
   * @type {string}
   * @memberof PartyListResponse
   */
  metAt?: string;
  /**
   *
   * @type {string}
   * @memberof PartyListResponse
   */
  shopName?: string;
  /**
   *
   * @type {string}
   * @memberof PartyListResponse
   */
  shopRoadAddress?: string;
  /**
   *
   * @type {string}
   * @memberof PartyListResponse
   */
  shopDetailAddress?: string;
  /**
   *
   * @type {string}
   * @memberof PartyListResponse
   */
  shopImage?: string;
}

export const PartyListResponseStatusEnum = {
  Recruiting: "RECRUITING",
  Completed: "COMPLETED",
  Terminated: "TERMINATED",
} as const;

export type PartyListResponseStatusEnum =
  (typeof PartyListResponseStatusEnum)[keyof typeof PartyListResponseStatusEnum];

/**
 *
 * @export
 * @interface PartyMemberResponse
 */
export interface PartyMemberResponse {
  /**
   * 파티원 ID
   * @type {number}
   * @memberof PartyMemberResponse
   */
  userId?: number;
  /**
   * 파티원 닉네임
   * @type {string}
   * @memberof PartyMemberResponse
   */
  userNickname?: string;
  /**
   * 파티원 프로필 이미지 URL
   * @type {string}
   * @memberof PartyMemberResponse
   */
  userProfile?: string;
  /**
   * 파티장 여부
   * @type {boolean}
   * @memberof PartyMemberResponse
   */
  isHost?: boolean;
}
/**
 *
 * @export
 * @interface PartyScrollResponse
 */
export interface PartyScrollResponse {
  /**
   *
   * @type {Array<PartyListResponse>}
   * @memberof PartyScrollResponse
   */
  content?: Array<PartyListResponse>;
  /**
   *
   * @type {number}
   * @memberof PartyScrollResponse
   */
  nextCursor?: number;
}
/**
 *
 * @export
 * @interface PaymentHistoryResponse
 */
export interface PaymentHistoryResponse {
  /**
   *
   * @type {number}
   * @memberof PaymentHistoryResponse
   */
  paymentId?: number;
  /**
   *
   * @type {string}
   * @memberof PaymentHistoryResponse
   */
  method?: string;
  /**
   *
   * @type {number}
   * @memberof PaymentHistoryResponse
   */
  totalAmount?: number;
  /**
   *
   * @type {string}
   * @memberof PaymentHistoryResponse
   */
  status?: PaymentHistoryResponseStatusEnum;
  /**
   *
   * @type {string}
   * @memberof PaymentHistoryResponse
   */
  createdAt?: string;
}

export const PaymentHistoryResponseStatusEnum = {
  Ready: "READY",
  InProgress: "IN_PROGRESS",
  WaitingForDeposit: "WAITING_FOR_DEPOSIT",
  Done: "DONE",
  Canceled: "CANCELED",
  PartialCanceled: "PARTIAL_CANCELED",
  Aborted: "ABORTED",
  Expired: "EXPIRED",
} as const;

export type PaymentHistoryResponseStatusEnum =
  (typeof PaymentHistoryResponseStatusEnum)[keyof typeof PaymentHistoryResponseStatusEnum];

/**
 *
 * @export
 * @interface PaymentScrollResponse
 */
export interface PaymentScrollResponse {
  /**
   *
   * @type {Array<PaymentHistoryResponse>}
   * @memberof PaymentScrollResponse
   */
  content?: Array<PaymentHistoryResponse>;
  /**
   *
   * @type {number}
   * @memberof PaymentScrollResponse
   */
  nextCursor?: number;
}
/**
 *
 * @export
 * @interface PaymentSuccessResponse
 */
export interface PaymentSuccessResponse {
  /**
   *
   * @type {string}
   * @memberof PaymentSuccessResponse
   */
  orderId?: string;
  /**
   *
   * @type {number}
   * @memberof PaymentSuccessResponse
   */
  totalAmount?: number;
}
/**
 *
 * @export
 * @interface PendingShop
 */
export interface PendingShop {
  /**
   *
   * @type {string}
   * @memberof PendingShop
   */
  shopName?: string;
  /**
   *
   * @type {number}
   * @memberof PendingShop
   */
  shopId?: number;
  /**
   *
   * @type {string}
   * @memberof PendingShop
   */
  userName?: string;
  /**
   *
   * @type {number}
   * @memberof PendingShop
   */
  userId?: number;
  /**
   *
   * @type {string}
   * @memberof PendingShop
   */
  address?: string;
  /**
   *
   * @type {string}
   * @memberof PendingShop
   */
  detailAddress?: string;
  /**
   *
   * @type {string}
   * @memberof PendingShop
   */
  tel?: string;
  /**
   *
   * @type {string}
   * @memberof PendingShop
   */
  approve?: PendingShopApproveEnum;
}

export const PendingShopApproveEnum = {
  Pending: "PENDING",
  Approved: "APPROVED",
  Rejected: "REJECTED",
} as const;

export type PendingShopApproveEnum =
  (typeof PendingShopApproveEnum)[keyof typeof PendingShopApproveEnum];

/**
 *
 * @export
 * @interface PreSignedUrlListResponse
 */
export interface PreSignedUrlListResponse {
  /**
   *
   * @type {Array<PreSignedUrlResponse>}
   * @memberof PreSignedUrlListResponse
   */
  items?: Array<PreSignedUrlResponse>;
  /**
   *
   * @type {number}
   * @memberof PreSignedUrlListResponse
   */
  refId?: number;
}
/**
 *
 * @export
 * @interface PreSignedUrlResponse
 */
export interface PreSignedUrlResponse {
  /**
   *
   * @type {string}
   * @memberof PreSignedUrlResponse
   */
  key?: string;
  /**
   *
   * @type {string}
   * @memberof PreSignedUrlResponse
   */
  url?: string;
}
/**
 * 예약 요약 정보 DTO
 * @export
 * @interface ReservationContent
 */
export interface ReservationContent {
  /**
   * 예약 ID
   * @type {number}
   * @memberof ReservationContent
   */
  reservationId?: number;
  /**
   * 식당 이름
   * @type {string}
   * @memberof ReservationContent
   */
  shopName?: string;
  /**
   * 예약 일시 (yyyy-MM-dd HH:mm)
   * @type {string}
   * @memberof ReservationContent
   */
  reservedAt?: string;
  /**
   * 예약 인원 수
   * @type {number}
   * @memberof ReservationContent
   */
  headCount?: number;
  /**
   * 예약자 전화번호
   * @type {string}
   * @memberof ReservationContent
   */
  phoneNumber?: string;
  /**
   * 예약상태
   * @type {string}
   * @memberof ReservationContent
   */
  status?: ReservationContentStatusEnum;
}

export const ReservationContentStatusEnum = {
  Pending: "PENDING",
  Cancelled: "CANCELLED",
  Confirmed: "CONFIRMED",
  Refused: "REFUSED",
  Terminated: "TERMINATED",
} as const;

export type ReservationContentStatusEnum =
  (typeof ReservationContentStatusEnum)[keyof typeof ReservationContentStatusEnum];

/**
 * 예약 목록 응답 DTO
 * @export
 * @interface ReservationListResponse
 */
export interface ReservationListResponse {
  /**
   * 예약 요약 정보 리스트
   * @type {Array<ReservationContent>}
   * @memberof ReservationListResponse
   */
  content?: Array<ReservationContent>;
  /**
   * 다음 페이지 커서. 더 이상 없으면 null
   * @type {number}
   * @memberof ReservationListResponse
   */
  nextCursor?: number;
}
/**
 *
 * @export
 * @interface ReviewCreateRequest
 */
export interface ReviewCreateRequest {
  /**
   * 예약 ID
   * @type {number}
   * @memberof ReviewCreateRequest
   */
  reservationId: number;
  /**
   * 음식점 ID
   * @type {number}
   * @memberof ReviewCreateRequest
   */
  shopId: number;
  /**
   * 리뷰 내용
   * @type {string}
   * @memberof ReviewCreateRequest
   */
  content: string;
  /**
   * 별점(0.5~5.0)
   * @type {number}
   * @memberof ReviewCreateRequest
   */
  rating: number;
  /**
   * 리뷰 이미지 목록
   * @type {number}
   * @memberof ReviewCreateRequest
   */
  imageCount?: number;
}
/**
 *
 * @export
 * @interface ReviewPageResponse
 */
export interface ReviewPageResponse {
  /**
   *
   * @type {number}
   * @memberof ReviewPageResponse
   */
  nextCursor?: number;
  /**
   *
   * @type {Array<ReviewResponse>}
   * @memberof ReviewPageResponse
   */
  content?: Array<ReviewResponse>;
}
/**
 *
 * @export
 * @interface ReviewResponse
 */
export interface ReviewResponse {
  /**
   *
   * @type {number}
   * @memberof ReviewResponse
   */
  reviewId?: number;
  /**
   *
   * @type {string}
   * @memberof ReviewResponse
   */
  userNickname?: string;
  /**
   *
   * @type {number}
   * @memberof ReviewResponse
   */
  rating?: number;
  /**
   *
   * @type {string}
   * @memberof ReviewResponse
   */
  content?: string;
  /**
   *
   * @type {string}
   * @memberof ReviewResponse
   */
  createdAt?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof ReviewResponse
   */
  images?: Array<string>;
}
/**
 *
 * @export
 * @interface ShopAdminDetailResponse
 */
export interface ShopAdminDetailResponse {
  /**
   *
   * @type {number}
   * @memberof ShopAdminDetailResponse
   */
  userId?: number;
  /**
   *
   * @type {string}
   * @memberof ShopAdminDetailResponse
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof ShopAdminDetailResponse
   */
  nickName?: string;
  /**
   *
   * @type {number}
   * @memberof ShopAdminDetailResponse
   */
  shopId?: number;
  /**
   *
   * @type {string}
   * @memberof ShopAdminDetailResponse
   */
  shopName?: string;
  /**
   *
   * @type {number}
   * @memberof ShopAdminDetailResponse
   */
  latitude?: number;
  /**
   *
   * @type {number}
   * @memberof ShopAdminDetailResponse
   */
  longitude?: number;
  /**
   *
   * @type {string}
   * @memberof ShopAdminDetailResponse
   */
  category?: ShopAdminDetailResponseCategoryEnum;
  /**
   *
   * @type {string}
   * @memberof ShopAdminDetailResponse
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof ShopAdminDetailResponse
   */
  roadAddress?: string;
  /**
   *
   * @type {string}
   * @memberof ShopAdminDetailResponse
   */
  detailAddress?: string;
  /**
   *
   * @type {string}
   * @memberof ShopAdminDetailResponse
   */
  tel?: string;
  /**
   *
   * @type {LocalTime}
   * @memberof ShopAdminDetailResponse
   */
  openTime?: LocalTime;
  /**
   *
   * @type {LocalTime}
   * @memberof ShopAdminDetailResponse
   */
  closeTime?: LocalTime;
  /**
   *
   * @type {number}
   * @memberof ShopAdminDetailResponse
   */
  rating?: number;
  /**
   *
   * @type {number}
   * @memberof ShopAdminDetailResponse
   */
  reservationFee?: number;
  /**
   *
   * @type {Array<string>}
   * @memberof ShopAdminDetailResponse
   */
  images?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof ShopAdminDetailResponse
   */
  businessCode?: string;
  /**
   *
   * @type {string}
   * @memberof ShopAdminDetailResponse
   */
  approve?: ShopAdminDetailResponseApproveEnum;
}

export const ShopAdminDetailResponseCategoryEnum = {
  Chicken: "CHICKEN",
  Chinese: "CHINESE",
  Japanese: "JAPANESE",
  Pizza: "PIZZA",
  Fastfood: "FASTFOOD",
  StewSoup: "STEW_SOUP",
  JokBo: "JOK_BO",
  Korean: "KOREAN",
  Snack: "SNACK",
  Western: "WESTERN",
  Dessert: "DESSERT",
} as const;

export type ShopAdminDetailResponseCategoryEnum =
  (typeof ShopAdminDetailResponseCategoryEnum)[keyof typeof ShopAdminDetailResponseCategoryEnum];
export const ShopAdminDetailResponseApproveEnum = {
  Pending: "PENDING",
  Approved: "APPROVED",
  Rejected: "REJECTED",
} as const;

export type ShopAdminDetailResponseApproveEnum =
  (typeof ShopAdminDetailResponseApproveEnum)[keyof typeof ShopAdminDetailResponseApproveEnum];

/**
 *
 * @export
 * @interface ShopCreateRequest
 */
export interface ShopCreateRequest {
  /**
   * 상점 이름
   * @type {string}
   * @memberof ShopCreateRequest
   */
  shopName: string;
  /**
   * 도로명 주소
   * @type {string}
   * @memberof ShopCreateRequest
   */
  roadAddress: string;
  /**
   * 상세 주소
   * @type {string}
   * @memberof ShopCreateRequest
   */
  detailAddress: string;
  /**
   * 시/도
   * @type {string}
   * @memberof ShopCreateRequest
   */
  sido: string;
  /**
   * 위도
   * @type {number}
   * @memberof ShopCreateRequest
   */
  latitude: number;
  /**
   * 경도
   * @type {number}
   * @memberof ShopCreateRequest
   */
  longitude: number;
  /**
   * 사업자 등록번호
   * @type {string}
   * @memberof ShopCreateRequest
   */
  businessCode: string;
  /**
   * 음식 카테고리 (아래 값 중 하나를 입력하세요): - CHICKEN: 치킨 - CHINESE: 중식 - JAPANESE: 일식 - PIZZA: 피자 - FASTFOOD: 패스트푸드 - STEW_SOUP: 찜/탕 - JOK_BO: 족발/보쌈 - KOREAN: 한식 - SNACK: 분식 - WESTERN: 양식 - DESSERT: 카페/디저트
   * @type {string}
   * @memberof ShopCreateRequest
   */
  category: ShopCreateRequestCategoryEnum;
  /**
   * 예약 수수료
   * @type {number}
   * @memberof ShopCreateRequest
   */
  reservationFee: number;
  /**
   * 영업 시작 시간
   * @type {string}
   * @memberof ShopCreateRequest
   */
  openTime?: string;
  /**
   * 영업 종료 시간
   * @type {string}
   * @memberof ShopCreateRequest
   */
  closeTime?: string;
  /**
   * 상점 설명
   * @type {string}
   * @memberof ShopCreateRequest
   */
  description: string;
  /**
   * 전화번호
   * @type {string}
   * @memberof ShopCreateRequest
   */
  tel: string;
  /**
   *
   * @type {number}
   * @memberof ShopCreateRequest
   */
  imageCount?: number;
}

export const ShopCreateRequestCategoryEnum = {
  Chicken: "CHICKEN",
  Chinese: "CHINESE",
  Japanese: "JAPANESE",
  Pizza: "PIZZA",
  Fastfood: "FASTFOOD",
  StewSoup: "STEW_SOUP",
  JokBo: "JOK_BO",
  Korean: "KOREAN",
  Snack: "SNACK",
  Western: "WESTERN",
  Dessert: "DESSERT",
} as const;

export type ShopCreateRequestCategoryEnum =
  (typeof ShopCreateRequestCategoryEnum)[keyof typeof ShopCreateRequestCategoryEnum];

/**
 *
 * @export
 * @interface ShopDetailResponse
 */
export interface ShopDetailResponse {
  /**
   *
   * @type {number}
   * @memberof ShopDetailResponse
   */
  shopId?: number;
  /**
   *
   * @type {string}
   * @memberof ShopDetailResponse
   */
  shopName?: string;
  /**
   *
   * @type {number}
   * @memberof ShopDetailResponse
   */
  latitude?: number;
  /**
   *
   * @type {number}
   * @memberof ShopDetailResponse
   */
  longitude?: number;
  /**
   *
   * @type {string}
   * @memberof ShopDetailResponse
   */
  category?: ShopDetailResponseCategoryEnum;
  /**
   *
   * @type {string}
   * @memberof ShopDetailResponse
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof ShopDetailResponse
   */
  roadAddress?: string;
  /**
   *
   * @type {string}
   * @memberof ShopDetailResponse
   */
  detailAddress?: string;
  /**
   *
   * @type {string}
   * @memberof ShopDetailResponse
   */
  tel?: string;
  /**
   *
   * @type {LocalTime}
   * @memberof ShopDetailResponse
   */
  openTime?: LocalTime;
  /**
   *
   * @type {LocalTime}
   * @memberof ShopDetailResponse
   */
  closeTime?: LocalTime;
  /**
   *
   * @type {number}
   * @memberof ShopDetailResponse
   */
  rating?: number;
  /**
   *
   * @type {number}
   * @memberof ShopDetailResponse
   */
  reservationFee?: number;
  /**
   *
   * @type {number}
   * @memberof ShopDetailResponse
   */
  reviewCount?: number;
  /**
   *
   * @type {Array<string>}
   * @memberof ShopDetailResponse
   */
  images?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof ShopDetailResponse
   */
  approve?: ShopDetailResponseApproveEnum;
}

export const ShopDetailResponseCategoryEnum = {
  Chicken: "CHICKEN",
  Chinese: "CHINESE",
  Japanese: "JAPANESE",
  Pizza: "PIZZA",
  Fastfood: "FASTFOOD",
  StewSoup: "STEW_SOUP",
  JokBo: "JOK_BO",
  Korean: "KOREAN",
  Snack: "SNACK",
  Western: "WESTERN",
  Dessert: "DESSERT",
} as const;

export type ShopDetailResponseCategoryEnum =
  (typeof ShopDetailResponseCategoryEnum)[keyof typeof ShopDetailResponseCategoryEnum];
export const ShopDetailResponseApproveEnum = {
  Pending: "PENDING",
  Approved: "APPROVED",
  Rejected: "REJECTED",
} as const;

export type ShopDetailResponseApproveEnum =
  (typeof ShopDetailResponseApproveEnum)[keyof typeof ShopDetailResponseApproveEnum];

/**
 *
 * @export
 * @interface ShopElementResponse
 */
export interface ShopElementResponse {
  /**
   *
   * @type {number}
   * @memberof ShopElementResponse
   */
  shopId?: number;
  /**
   *
   * @type {string}
   * @memberof ShopElementResponse
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof ShopElementResponse
   */
  category?: ShopElementResponseCategoryEnum;
  /**
   *
   * @type {string}
   * @memberof ShopElementResponse
   */
  address?: string;
  /**
   *
   * @type {string}
   * @memberof ShopElementResponse
   */
  detailAddress?: string;
  /**
   *
   * @type {number}
   * @memberof ShopElementResponse
   */
  rating?: number;
  /**
   *
   * @type {string}
   * @memberof ShopElementResponse
   */
  thumbnailUrl?: string;
  /**
   *
   * @type {number}
   * @memberof ShopElementResponse
   */
  latitude?: number;
  /**
   *
   * @type {number}
   * @memberof ShopElementResponse
   */
  longitude?: number;
}

export const ShopElementResponseCategoryEnum = {
  Chicken: "CHICKEN",
  Chinese: "CHINESE",
  Japanese: "JAPANESE",
  Pizza: "PIZZA",
  Fastfood: "FASTFOOD",
  StewSoup: "STEW_SOUP",
  JokBo: "JOK_BO",
  Korean: "KOREAN",
  Snack: "SNACK",
  Western: "WESTERN",
  Dessert: "DESSERT",
} as const;

export type ShopElementResponseCategoryEnum =
  (typeof ShopElementResponseCategoryEnum)[keyof typeof ShopElementResponseCategoryEnum];

/**
 *
 * @export
 * @interface ShopOwnerDetailResponse
 */
export interface ShopOwnerDetailResponse {
  /**
   *
   * @type {number}
   * @memberof ShopOwnerDetailResponse
   */
  shopId?: number;
  /**
   *
   * @type {string}
   * @memberof ShopOwnerDetailResponse
   */
  shopName?: string;
  /**
   *
   * @type {number}
   * @memberof ShopOwnerDetailResponse
   */
  latitude?: number;
  /**
   *
   * @type {number}
   * @memberof ShopOwnerDetailResponse
   */
  longitude?: number;
  /**
   *
   * @type {string}
   * @memberof ShopOwnerDetailResponse
   */
  category?: ShopOwnerDetailResponseCategoryEnum;
  /**
   *
   * @type {string}
   * @memberof ShopOwnerDetailResponse
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof ShopOwnerDetailResponse
   */
  roadAddress?: string;
  /**
   *
   * @type {string}
   * @memberof ShopOwnerDetailResponse
   */
  detailAddress?: string;
  /**
   *
   * @type {string}
   * @memberof ShopOwnerDetailResponse
   */
  tel?: string;
  /**
   *
   * @type {LocalTime}
   * @memberof ShopOwnerDetailResponse
   */
  openTime?: LocalTime;
  /**
   *
   * @type {LocalTime}
   * @memberof ShopOwnerDetailResponse
   */
  closeTime?: LocalTime;
  /**
   *
   * @type {number}
   * @memberof ShopOwnerDetailResponse
   */
  rating?: number;
  /**
   *
   * @type {number}
   * @memberof ShopOwnerDetailResponse
   */
  reservationFee?: number;
  /**
   *
   * @type {number}
   * @memberof ShopOwnerDetailResponse
   */
  reviewCount?: number;
  /**
   *
   * @type {Array<string>}
   * @memberof ShopOwnerDetailResponse
   */
  images?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof ShopOwnerDetailResponse
   */
  businessCode?: string;
  /**
   *
   * @type {string}
   * @memberof ShopOwnerDetailResponse
   */
  approve?: ShopOwnerDetailResponseApproveEnum;
}

export const ShopOwnerDetailResponseCategoryEnum = {
  Chicken: "CHICKEN",
  Chinese: "CHINESE",
  Japanese: "JAPANESE",
  Pizza: "PIZZA",
  Fastfood: "FASTFOOD",
  StewSoup: "STEW_SOUP",
  JokBo: "JOK_BO",
  Korean: "KOREAN",
  Snack: "SNACK",
  Western: "WESTERN",
  Dessert: "DESSERT",
} as const;

export type ShopOwnerDetailResponseCategoryEnum =
  (typeof ShopOwnerDetailResponseCategoryEnum)[keyof typeof ShopOwnerDetailResponseCategoryEnum];
export const ShopOwnerDetailResponseApproveEnum = {
  Pending: "PENDING",
  Approved: "APPROVED",
  Rejected: "REJECTED",
} as const;

export type ShopOwnerDetailResponseApproveEnum =
  (typeof ShopOwnerDetailResponseApproveEnum)[keyof typeof ShopOwnerDetailResponseApproveEnum];

/**
 *
 * @export
 * @interface ShopPageResponse
 */
export interface ShopPageResponse {
  /**
   *
   * @type {string}
   * @memberof ShopPageResponse
   */
  nextCursor?: string;
  /**
   *
   * @type {Array<ShopElementResponse>}
   * @memberof ShopPageResponse
   */
  shops?: Array<ShopElementResponse>;
}
/**
 *
 * @export
 * @interface ShopUpdateRequest
 */
export interface ShopUpdateRequest {
  /**
   * 상점 이름
   * @type {string}
   * @memberof ShopUpdateRequest
   */
  shopName?: string;
  /**
   * 도로명 주소
   * @type {string}
   * @memberof ShopUpdateRequest
   */
  roadAddress?: string;
  /**
   * 상세 주소
   * @type {string}
   * @memberof ShopUpdateRequest
   */
  detailAddress?: string;
  /**
   * 시/도
   * @type {string}
   * @memberof ShopUpdateRequest
   */
  sido?: string;
  /**
   * 위도
   * @type {number}
   * @memberof ShopUpdateRequest
   */
  latitude?: number;
  /**
   * 경도
   * @type {number}
   * @memberof ShopUpdateRequest
   */
  longitude?: number;
  /**
   * 사업자 등록번호
   * @type {string}
   * @memberof ShopUpdateRequest
   */
  businessCode?: string;
  /**
   * 음식 카테고리
   * @type {string}
   * @memberof ShopUpdateRequest
   */
  category?: ShopUpdateRequestCategoryEnum;
  /**
   * 예약 수수료
   * @type {number}
   * @memberof ShopUpdateRequest
   */
  reservationFee?: number;
  /**
   *
   * @type {LocalTime}
   * @memberof ShopUpdateRequest
   */
  openTime?: LocalTime;
  /**
   *
   * @type {LocalTime}
   * @memberof ShopUpdateRequest
   */
  closeTime?: LocalTime;
  /**
   * 상점 설명
   * @type {string}
   * @memberof ShopUpdateRequest
   */
  description?: string;
  /**
   * 전화번호
   * @type {string}
   * @memberof ShopUpdateRequest
   */
  tel?: string;
  /**
   * 이미지 개수
   * @type {number}
   * @memberof ShopUpdateRequest
   */
  imageCount?: number;
}

export const ShopUpdateRequestCategoryEnum = {
  Chicken: "CHICKEN",
  Chinese: "CHINESE",
  Japanese: "JAPANESE",
  Pizza: "PIZZA",
  Fastfood: "FASTFOOD",
  StewSoup: "STEW_SOUP",
  JokBo: "JOK_BO",
  Korean: "KOREAN",
  Snack: "SNACK",
  Western: "WESTERN",
  Dessert: "DESSERT",
} as const;

export type ShopUpdateRequestCategoryEnum =
  (typeof ShopUpdateRequestCategoryEnum)[keyof typeof ShopUpdateRequestCategoryEnum];

/**
 *
 * @export
 * @interface ShopsItem
 */
export interface ShopsItem {
  /**
   *
   * @type {number}
   * @memberof ShopsItem
   */
  shopId?: number;
  /**
   *
   * @type {string}
   * @memberof ShopsItem
   */
  shopName?: string;
  /**
   *
   * @type {string}
   * @memberof ShopsItem
   */
  category?: ShopsItemCategoryEnum;
  /**
   *
   * @type {string}
   * @memberof ShopsItem
   */
  roadAddress?: string;
  /**
   *
   * @type {string}
   * @memberof ShopsItem
   */
  detailAddress?: string;
  /**
   *
   * @type {number}
   * @memberof ShopsItem
   */
  latitude?: number;
  /**
   *
   * @type {number}
   * @memberof ShopsItem
   */
  longitude?: number;
  /**
   *
   * @type {number}
   * @memberof ShopsItem
   */
  rating?: number;
  /**
   *
   * @type {string}
   * @memberof ShopsItem
   */
  thumbnailUrl?: string;
}

export const ShopsItemCategoryEnum = {
  Chicken: "CHICKEN",
  Chinese: "CHINESE",
  Japanese: "JAPANESE",
  Pizza: "PIZZA",
  Fastfood: "FASTFOOD",
  StewSoup: "STEW_SOUP",
  JokBo: "JOK_BO",
  Korean: "KOREAN",
  Snack: "SNACK",
  Western: "WESTERN",
  Dessert: "DESSERT",
} as const;

export type ShopsItemCategoryEnum =
  (typeof ShopsItemCategoryEnum)[keyof typeof ShopsItemCategoryEnum];

/**
 *
 * @export
 * @interface ShopsResponse
 */
export interface ShopsResponse {
  /**
   *
   * @type {number}
   * @memberof ShopsResponse
   */
  nextCursor?: number;
  /**
   *
   * @type {Array<ShopsItem>}
   * @memberof ShopsResponse
   */
  content?: Array<ShopsItem>;
}
/**
 *
 * @export
 * @interface SignUpRequest
 */
export interface SignUpRequest {
  /**
   *
   * @type {string}
   * @memberof SignUpRequest
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof SignUpRequest
   */
  password: string;
  /**
   *
   * @type {string}
   * @memberof SignUpRequest
   */
  nickname: string;
  /**
   *
   * @type {string}
   * @memberof SignUpRequest
   */
  phoneNumber: string;
  /**
   *
   * @type {string}
   * @memberof SignUpRequest
   */
  name: string;
  /**
   *
   * @type {number}
   * @memberof SignUpRequest
   */
  age?: number;
  /**
   *
   * @type {string}
   * @memberof SignUpRequest
   */
  gender: SignUpRequestGenderEnum;
}

export const SignUpRequestGenderEnum = {
  M: "M",
  W: "W",
} as const;

export type SignUpRequestGenderEnum =
  (typeof SignUpRequestGenderEnum)[keyof typeof SignUpRequestGenderEnum];

/**
 *
 * @export
 * @interface TossPaymentConfirmRequest
 */
export interface TossPaymentConfirmRequest {
  /**
   * 결제 성공 시 토스에서 쿼리 파라미터로 반환해주는 paymentKey
   * @type {string}
   * @memberof TossPaymentConfirmRequest
   */
  paymentKey: string;
  /**
   * 클라이언트에서 생성한 주문 id
   * @type {string}
   * @memberof TossPaymentConfirmRequest
   */
  orderId: string;
  /**
   * 결제 금액(1000~50000원)
   * @type {number}
   * @memberof TossPaymentConfirmRequest
   */
  amount?: number;
}
/**
 *
 * @export
 * @interface Writer
 */
export interface Writer {
  /**
   *
   * @type {number}
   * @memberof Writer
   */
  userId?: number;
  /**
   *
   * @type {string}
   * @memberof Writer
   */
  nickname?: string;
}

/**
 * APIApi - axios parameter creator
 * @export
 */
export const APIApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminTest: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/admin/test`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication accessToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication refreshToken required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * reservationId에 해당하는 예약을 CANCELLED 상태로 변경한다. (Completed)
     * @summary 예약 취소
     * @param {number} reservationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelReservation: async (
      reservationId: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'reservationId' is not null or undefined
      assertParamExists("cancelReservation", "reservationId", reservationId);
      const localVarPath = `/reservations/{reservationId}/cancel`.replace(
        `{${"reservationId"}}`,
        encodeURIComponent(String(reservationId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication accessToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication refreshToken required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 모집중인 파티를 모집종료 상태로 변경합니다.(Completed)
     * @summary 파티 모집 완료 상태 변경
     * @param {number} partyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    completeParty: async (
      partyId: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'partyId' is not null or undefined
      assertParamExists("completeParty", "partyId", partyId);
      const localVarPath = `/parties/{partyId}/complete`.replace(
        `{${"partyId"}}`,
        encodeURIComponent(String(partyId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication accessToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication refreshToken required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 결제 성공 시 (WidgetSuccess로 이동할 때) 이 api를 호출해서 최종 결제 승인 및 저장을 실행합니다. 이 api 에서 에러가 발생할 시 fail path로 리다이렉트합니다. (Completed)
     * @summary 결제 승인 api
     * @param {TossPaymentConfirmRequest} tossPaymentConfirmRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    confirm: async (
      tossPaymentConfirmRequest: TossPaymentConfirmRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'tossPaymentConfirmRequest' is not null or undefined
      assertParamExists(
        "confirm",
        "tossPaymentConfirmRequest",
        tossPaymentConfirmRequest
      );
      const localVarPath = `/payment/confirm`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication accessToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication refreshToken required

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        tossPaymentConfirmRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * reservationId에 해당하는 예약을 CONFIRMED 상태로 변경한다. (Completed)
     * @summary 예약 수락
     * @param {number} reservationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    confirmReservation: async (
      reservationId: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'reservationId' is not null or undefined
      assertParamExists("confirmReservation", "reservationId", reservationId);
      const localVarPath = `/reservations/{reservationId}/confirm`.replace(
        `{${"reservationId"}}`,
        encodeURIComponent(String(reservationId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication accessToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication refreshToken required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 특정 모임에 댓글을 작성합니다.(Completed)
     * @summary 댓글 작성
     * @param {number} partyId
     * @param {CommentCreateRequest} commentCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createComment: async (
      partyId: number,
      commentCreateRequest: CommentCreateRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'partyId' is not null or undefined
      assertParamExists("createComment", "partyId", partyId);
      // verify required parameter 'commentCreateRequest' is not null or undefined
      assertParamExists(
        "createComment",
        "commentCreateRequest",
        commentCreateRequest
      );
      const localVarPath = `/parties/{partyId}/comments`.replace(
        `{${"partyId"}}`,
        encodeURIComponent(String(partyId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication accessToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication refreshToken required

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        commentCreateRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 특정 모임에 댓글을 작성합니다.(Completed)
     * @summary 고객센터 댓글 작성
     * @param {number} inquiryId
     * @param {CommentCreateRequest} commentCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createInquiryComment: async (
      inquiryId: number,
      commentCreateRequest: CommentCreateRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'inquiryId' is not null or undefined
      assertParamExists("createInquiryComment", "inquiryId", inquiryId);
      // verify required parameter 'commentCreateRequest' is not null or undefined
      assertParamExists(
        "createInquiryComment",
        "commentCreateRequest",
        commentCreateRequest
      );
      const localVarPath = `/inquiry/{inquiryId}/comments`.replace(
        `{${"inquiryId"}}`,
        encodeURIComponent(String(inquiryId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication accessToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication refreshToken required

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        commentCreateRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 맛집 탐험 파티 모집 게시글을 작성합니다.(Completed)
     * @summary 파티 생성
     * @param {PartyCreateRequest} partyCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createParty: async (
      partyCreateRequest: PartyCreateRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'partyCreateRequest' is not null or undefined
      assertParamExists(
        "createParty",
        "partyCreateRequest",
        partyCreateRequest
      );
      const localVarPath = `/parties`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication accessToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication refreshToken required

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        partyCreateRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * shopId에 해당하는 식당에 예약을 생성한다. 파티 예약인 경우 partyId를 쿼리 파라미터로 전달해야 한다.(Completed)
     * @summary 예약 생성
     * @param {number} shopId
     * @param {CreateReservationRequest} createReservationRequest
     * @param {} [UNKNOWN_PARAMETER_NAME] 파티 ID (선택값). 파티 예약일 경우 전달.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createReservation: async (
      shopId: number,
      createReservationRequest: CreateReservationRequest,
      UNKNOWN_PARAMETER_NAME?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'shopId' is not null or undefined
      assertParamExists("createReservation", "shopId", shopId);
      // verify required parameter 'createReservationRequest' is not null or undefined
      assertParamExists(
        "createReservation",
        "createReservationRequest",
        createReservationRequest
      );
      const localVarPath = `/shops/{shopId}/reservations`.replace(
        `{${"shopId"}}`,
        encodeURIComponent(String(shopId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication accessToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication refreshToken required

      if (UNKNOWN_PARAMETER_NAME !== undefined) {
        localVarQueryParameter["partyId"] = UNKNOWN_PARAMETER_NAME;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createReservationRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 리뷰를 작성합니다.(Completed)
     * @summary 리뷰 작성
     * @param {ReviewCreateRequest} reviewCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createReview: async (
      reviewCreateRequest: ReviewCreateRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'reviewCreateRequest' is not null or undefined
      assertParamExists(
        "createReview",
        "reviewCreateRequest",
        reviewCreateRequest
      );
      const localVarPath = `/reviews`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication accessToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication refreshToken required

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        reviewCreateRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 사용자는 새로운 식당을 생성합니다.(Completed)  사진 전송 시 헤더에 Cache-Control 값이 no-cache,no-store,must-revalidate 되어 있어야 합니다
     * @summary 식당 생성
     * @param {ShopCreateRequest} shopCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createShop: async (
      shopCreateRequest: ShopCreateRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'shopCreateRequest' is not null or undefined
      assertParamExists("createShop", "shopCreateRequest", shopCreateRequest);
      const localVarPath = `/shops/presigned-urls`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication accessToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication refreshToken required

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        shopCreateRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 특정 댓글을 삭제합니다.(Completed)
     * @summary 댓글 삭제
     * @param {number} commentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteComment: async (
      commentId: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'commentId' is not null or undefined
      assertParamExists("deleteComment", "commentId", commentId);
      const localVarPath = `/comments/{commentId}`.replace(
        `{${"commentId"}}`,
        encodeURIComponent(String(commentId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication accessToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication refreshToken required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 맛집 탐험 파티 게시글을 삭제합니다.(Completed)
     * @summary 파티 삭제
     * @param {number} partyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteParty: async (
      partyId: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'partyId' is not null or undefined
      assertParamExists("deleteParty", "partyId", partyId);
      const localVarPath = `/parties/{partyId}`.replace(
        `{${"partyId"}}`,
        encodeURIComponent(String(partyId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication accessToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication refreshToken required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 프로필 수정 작업 중 예외 발생으로 업로드된 이미지를 삭제합니다.(Completed)
     * @summary 프로필 이미지 삭제
     * @param {DeleteProfileRequest} deleteProfileRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteProfile: async (
      deleteProfileRequest: DeleteProfileRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'deleteProfileRequest' is not null or undefined
      assertParamExists(
        "deleteProfile",
        "deleteProfileRequest",
        deleteProfileRequest
      );
      const localVarPath = `/users/my-page/profile-img`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication accessToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication refreshToken required

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        deleteProfileRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 특정 리뷰를 삭제합니다.(Completed)
     * @summary 리뷰 삭제
     * @param {number} reviewId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteReview: async (
      reviewId: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'reviewId' is not null or undefined
      assertParamExists("deleteReview", "reviewId", reviewId);
      const localVarPath = `/reviews/{reviewId}`.replace(
        `{${"reviewId"}}`,
        encodeURIComponent(String(reviewId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication accessToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication refreshToken required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 회원 탈퇴 기능(Inprogress)
     * @summary 회원탈퇴
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/users/delete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication accessToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication refreshToken required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 문의글 전체를 조회합니다. (Completed)
     * @summary 고객센터의 문의글 전체 조회
     * @param {number} [cursor]
     * @param {number} [size]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllInquiry: async (
      cursor?: number,
      size?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/inquiry`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication accessToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication refreshToken required

      if (cursor !== undefined) {
        localVarQueryParameter["cursor"] = cursor;
      }

      if (size !== undefined) {
        localVarQueryParameter["size"] = size;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 특정 모임의 댓글 목록을 조회합니다.(Completed)
     * @summary 댓글 조회
     * @param {number} partyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getComments: async (
      partyId: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'partyId' is not null or undefined
      assertParamExists("getComments", "partyId", partyId);
      const localVarPath = `/parties/{partyId}/comments`.replace(
        `{${"partyId"}}`,
        encodeURIComponent(String(partyId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication accessToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication refreshToken required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 사용자가 특정 식당의 상세 정보를 조회합니다. 식당 등록 상태가 APPROVED인 식당들만 조회 가능 (Completed)
     * @summary 식당 상세 조회
     * @param {number} shopId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDetailShop: async (
      shopId: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'shopId' is not null or undefined
      assertParamExists("getDetailShop", "shopId", shopId);
      const localVarPath = `/shops/{shopId}`.replace(
        `{${"shopId"}}`,
        encodeURIComponent(String(shopId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication accessToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication refreshToken required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 자신이 가진 식당의 상세 정보를 조회합니다. (Completed)
     * @summary 사장의 식당 상세 조회
     * @param {number} shopId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDetailShopOwner: async (
      shopId: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'shopId' is not null or undefined
      assertParamExists("getDetailShopOwner", "shopId", shopId);
      const localVarPath = `/owner/shops/{shopId}`.replace(
        `{${"shopId"}}`,
        encodeURIComponent(String(shopId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication accessToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication refreshToken required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 특정 모임의 댓글 목록을 조회합니다.(Completed)
     * @summary 고객센터 댓글 조회
     * @param {number} inquiryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInquiryComments: async (
      inquiryId: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'inquiryId' is not null or undefined
      assertParamExists("getInquiryComments", "inquiryId", inquiryId);
      const localVarPath = `/inquiry/{inquiryId}/comments`.replace(
        `{${"inquiryId"}}`,
        encodeURIComponent(String(inquiryId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication accessToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication refreshToken required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 로그인한 사용자의 마이페이지 정보를 조회합니다.(Completed)
     * @summary 내 정보 조회
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMyInfo: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/users/my-page`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication accessToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication refreshToken required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 로그인한 사용자의 파티 목록을 커서 기반 페이징 방식으로 조회합니다.(Completed)
     * @summary 내 파티 정보 조회
     * @param {number} [size]
     * @param {number} [cursor]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMyParties: async (
      size?: number,
      cursor?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/users/my-page/parties`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication accessToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication refreshToken required

      if (size !== undefined) {
        localVarQueryParameter["size"] = size;
      }

      if (cursor !== undefined) {
        localVarQueryParameter["cursor"] = cursor;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 로그인한 사용자의 예약 목록을 커서 기반 페이징 방식으로 조회합니다.(Completed)
     * @summary 내 예약 정보 조회
     * @param {number} [size]
     * @param {number} [cursor]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMyReservations: async (
      size?: number,
      cursor?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/users/my-page/reservations`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication accessToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication refreshToken required

      if (size !== undefined) {
        localVarQueryParameter["size"] = size;
      }

      if (cursor !== undefined) {
        localVarQueryParameter["cursor"] = cursor;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 로그인한 사용자가 작성한 리뷰 목록을 커서 기반 페이징 방식으로 조회합니다.(Completed)
     * @summary 내 리뷰 정보 조회
     * @param {number} [size]
     * @param {number} [cursor]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMyReviews: async (
      size?: number,
      cursor?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/users/my-page/reviews`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication accessToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication refreshToken required

      if (size !== undefined) {
        localVarQueryParameter["size"] = size;
      }

      if (cursor !== undefined) {
        localVarQueryParameter["cursor"] = cursor;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 본인이 작성한 경우이거나 관리자의 경우에만 조회가 가능합니다. (Completed)
     * @summary 자신이 작성한 고객센터의 문의글 하나 상세 조회
     * @param {number} inquiryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOneInquiry: async (
      inquiryId: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'inquiryId' is not null or undefined
      assertParamExists("getOneInquiry", "inquiryId", inquiryId);
      const localVarPath = `/inquiry/{inquiryId}`.replace(
        `{${"inquiryId"}}`,
        encodeURIComponent(String(inquiryId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication accessToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication refreshToken required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 사장 한명이 가진 식당들 리스트들을 조회합니다. 승인 여부 상태와 상관없이 조회 (Completed)
     * @summary 사장이 가진 식당들 조회
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOwnerShops: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/owner/shops`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication accessToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication refreshToken required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 파티 상태, 위치, 음식 카테고리로 필터링한 파티 게시글 목록을 조회합니다. (Completed)  예시 /parties?status=RECRUITING&minAge=10&categories=CHICKEN&categories=JAPANESE  | 필드 명     | 자료형    | 필수 여부  | 설명                                            | 기본값                   | |------------|---------|-----------|-------------------------------------------------|------------------------| | status     | string  | Optional  | 파티 상태                                        | 전체                    | | gender     | string  | Optional  | 모집 성별 조건(A일 시 성별 무관인 파티만 조회합니다.)   |  전체                   | | minAge     | int     | Optional  | 모집 최소 나이                                    | 전체                    | | maxAge     | int     | Optional  | 모집 최대 나이                                    | 전체                    | | location   | string  | Optional  | 시/도 단위 파티 위치                               | 전체                    | | category   | string  | Optional  | 음식 카테고리 (다중 선택 가능)                       | 전체                    | | query      | string  | Optional  | 파티 제목 검색 키워드                               | 전체                    | | cursor       | int  | Optional   | 페이징 마지막 파티 id                               | 첫번째 페이지            |
     * @summary 파티 목록 조회
     * @param {GetPartiesStatusEnum} [status]
     * @param {GetPartiesGenderEnum} [gender]
     * @param {number} [minAge]
     * @param {number} [maxAge]
     * @param {string} [location]
     * @param {Array<GetPartiesCategoriesEnum>} [categories]
     * @param {string} [query]
     * @param {number} [cursor]
     * @param {number} [size]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getParties: async (
      status?: GetPartiesStatusEnum,
      gender?: GetPartiesGenderEnum,
      minAge?: number,
      maxAge?: number,
      location?: string,
      categories?: Array<GetPartiesCategoriesEnum>,
      query?: string,
      cursor?: number,
      size?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/parties`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication accessToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication refreshToken required

      if (status !== undefined) {
        localVarQueryParameter["status"] = status;
      }

      if (gender !== undefined) {
        localVarQueryParameter["gender"] = gender;
      }

      if (minAge !== undefined) {
        localVarQueryParameter["minAge"] = minAge;
      }

      if (maxAge !== undefined) {
        localVarQueryParameter["maxAge"] = maxAge;
      }

      if (location !== undefined) {
        localVarQueryParameter["location"] = location;
      }

      if (categories) {
        localVarQueryParameter["categories"] = categories;
      }

      if (query !== undefined) {
        localVarQueryParameter["query"] = query;
      }

      if (cursor !== undefined) {
        localVarQueryParameter["cursor"] = cursor;
      }

      if (size !== undefined) {
        localVarQueryParameter["size"] = size;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 맛집 탐험 파티 상세 정보를 조회합니다.(Completed)
     * @summary 파티 상세 조회
     * @param {number} partyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPartyDetail: async (
      partyId: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'partyId' is not null or undefined
      assertParamExists("getPartyDetail", "partyId", partyId);
      const localVarPath = `/parties/{partyId}`.replace(
        `{${"partyId"}}`,
        encodeURIComponent(String(partyId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication accessToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication refreshToken required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 맛집 탐험 파티원 목록을 조회합니다.(Completed)
     * @summary 파티원 목록 조회
     * @param {number} partyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPartyMembers: async (
      partyId: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'partyId' is not null or undefined
      assertParamExists("getPartyMembers", "partyId", partyId);
      const localVarPath = `/parties/{partyId}/members`.replace(
        `{${"partyId"}}`,
        encodeURIComponent(String(partyId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication accessToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication refreshToken required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 결제 내역을 스크롤 방식으로 조회합니다. 사용자의 마이페이지 란에서 조회 가능합니다. (Completed)
     * @summary 결제 내역 조회 api
     * @param {number} [size]
     * @param {number} [cursor]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentHistories: async (
      size?: number,
      cursor?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/payment`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication accessToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication refreshToken required

      if (size !== undefined) {
        localVarQueryParameter["size"] = size;
      }

      if (cursor !== undefined) {
        localVarQueryParameter["cursor"] = cursor;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * APPROVED(승인) 또는 REJECTED(거절) (Completed)
     * @summary 관리자가 식당 등록에 대한 요청을 승인 또는 거절
     * @param {number} shopId
     * @param {ApproveRequest} approveRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPendingShop: async (
      shopId: number,
      approveRequest: ApproveRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'shopId' is not null or undefined
      assertParamExists("getPendingShop", "shopId", shopId);
      // verify required parameter 'approveRequest' is not null or undefined
      assertParamExists("getPendingShop", "approveRequest", approveRequest);
      const localVarPath = `/admin/shops/{shopId}`.replace(
        `{${"shopId"}}`,
        encodeURIComponent(String(shopId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication accessToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication refreshToken required

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        approveRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 관리자는 등록을 원하는 식당 리스트를 볼 수 있습니다. (Completed)
     * @summary 관리자가 pending 상태인 식당들 리스트를 가져옴
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPendingShop1: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/admin/shops`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication accessToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication refreshToken required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 내 정보 수정 항목 중 프로필 이미지를 업로드하기 위한 pre-signed url을 생성합니다.(Completed)
     * @summary 프로필 이미지 업로드를 위한 pre-signed url 생성
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProfilePresignedUrl: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/users/my-page/presigned-urls`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication accessToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication refreshToken required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 식당의 예약 목록을 필터와 커서 기반으로 조회한다.(Completed)
     * @summary 식당 예약 목록 조회
     * @param {GetReservationsFilterEnum} [filter]
     * @param {number} [cursor]
     * @param {number} [size]
     * @param {number} [shopId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReservations: async (
      filter?: GetReservationsFilterEnum,
      cursor?: number,
      size?: number,
      shopId?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/reservations`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication accessToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication refreshToken required

      if (filter !== undefined) {
        localVarQueryParameter["filter"] = filter;
      }

      if (cursor !== undefined) {
        localVarQueryParameter["cursor"] = cursor;
      }

      if (size !== undefined) {
        localVarQueryParameter["size"] = size;
      }

      if (shopId !== undefined) {
        localVarQueryParameter["shopId"] = shopId;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 특정 가게의 리뷰 목록을 조회합니다.(Completed)
     * @summary 리뷰 조회
     * @param {number} shopId
     * @param {number} [cursor]
     * @param {number} [size]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReviews: async (
      shopId: number,
      cursor?: number,
      size?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'shopId' is not null or undefined
      assertParamExists("getReviews", "shopId", shopId);
      const localVarPath = `/shops/{shopId}/reviews`.replace(
        `{${"shopId"}}`,
        encodeURIComponent(String(shopId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication accessToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication refreshToken required

      if (cursor !== undefined) {
        localVarQueryParameter["cursor"] = cursor;
      }

      if (size !== undefined) {
        localVarQueryParameter["size"] = size;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 관리자는 식당에 대한 정보를 볼 수 있습니다. (식당의 등록 상태가 뭐든 볼 수 있음) (Completed)
     * @summary 관리자가 식당에 대한 정보를 봄
     * @param {number} shopId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getShopAdminDetail: async (
      shopId: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'shopId' is not null or undefined
      assertParamExists("getShopAdminDetail", "shopId", shopId);
      const localVarPath = `/admin/shops/{shopId}`.replace(
        `{${"shopId"}}`,
        encodeURIComponent(String(shopId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication accessToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication refreshToken required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 일반 사용자가 위치 기반으로 식당 목록을 조회합니다. (식당 상태가 APPROVED인 식당들만 조회 가능) (Completed)  반경은 m 단위로 주시면 되며 ->  3km (3000) 만약 사용자가 자신의 위치를 허용한다면 latitude과 longitude에 사용자 위도 경도, 원하는 범위를 넣어서 요청을 보내고 그렇지 않는다면 기본값으론 종로구 좌표에 3km 범위 식당을 가져옵니다  예시 /shops?radius=1000000&sort=rating  | 필드 명     | 자료형  | 필수 여부 | 설명                   | 기본값           | |------------|---------|-----------|-------------------------|------------------| | latitude   | double  | Required  | 사용자 위치의 위도         | 37.5724          | | longitude  | double  | Required  | 사용자 위치의 경도         | 126.9794         | | radius     | double  | Optional  | 검색 반경 (단위: m)       | 3000.0           | | category   | string  | Optional  | 음식 카테고리             | 전체             | | sort       | string  | Optional  | 정렬 기준 (근처순, 평점순) | 근처 순(distance) |
     * @summary 식당 목록 조회
     * @param {number} [latitude]
     * @param {number} [longitude]
     * @param {number} [radius]
     * @param {Array<GetShopsCategoryEnum>} [category]
     * @param {string} [sort]
     * @param {number} [cursor]
     * @param {number} [size]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getShops: async (
      latitude?: number,
      longitude?: number,
      radius?: number,
      category?: Array<GetShopsCategoryEnum>,
      sort?: string,
      cursor?: number,
      size?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/shops`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication accessToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication refreshToken required

      if (latitude !== undefined) {
        localVarQueryParameter["latitude"] = latitude;
      }

      if (longitude !== undefined) {
        localVarQueryParameter["longitude"] = longitude;
      }

      if (radius !== undefined) {
        localVarQueryParameter["radius"] = radius;
      }

      if (category) {
        localVarQueryParameter["category"] = category;
      }

      if (sort !== undefined) {
        localVarQueryParameter["sort"] = sort;
      }

      if (cursor !== undefined) {
        localVarQueryParameter["cursor"] = cursor;
      }

      if (size !== undefined) {
        localVarQueryParameter["size"] = size;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 키워드로 식당을 검색합니다.정렬기준: NAME, CREATED_AT, RATING  (식당 상태가 APPROVED인 식당들만 조회 가능)(Completed)
     * @summary 식당 검색
     * @param {string} [query]
     * @param {GetShopsBySearchSortEnum} [sort]
     * @param {string} [cursor]
     * @param {number} [size]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getShopsBySearch: async (
      query?: string,
      sort?: GetShopsBySearchSortEnum,
      cursor?: string,
      size?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/shops/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication accessToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication refreshToken required

      if (query !== undefined) {
        localVarQueryParameter["query"] = query;
      }

      if (sort !== undefined) {
        localVarQueryParameter["sort"] = sort;
      }

      if (cursor !== undefined) {
        localVarQueryParameter["cursor"] = cursor;
      }

      if (size !== undefined) {
        localVarQueryParameter["size"] = size;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 맛집 탐험 파티를 참여합니다.(Completed)
     * @summary 파티 참여
     * @param {number} partyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    joinParty: async (
      partyId: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'partyId' is not null or undefined
      assertParamExists("joinParty", "partyId", partyId);
      const localVarPath = `/parties/{partyId}/join`.replace(
        `{${"partyId"}}`,
        encodeURIComponent(String(partyId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication accessToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication refreshToken required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 폼 로그인으로 로그인합니다. 성공 시 액세스 토큰은 헤더, 리프레시 토큰은 쿠키에 포함됩니다.(Completed)
     * @summary Form 로그인
     * @param {LoginRequest} loginRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    login: async (
      loginRequest: LoginRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'loginRequest' is not null or undefined
      assertParamExists("login", "loginRequest", loginRequest);
      const localVarPath = `/users/login`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication accessToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication refreshToken required

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        loginRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 쿠키의 리프레시 토큰을 무효화하고 로그아웃 처리합니다.
     * @summary 로그아웃
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logout: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/users/logout`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication accessToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication refreshToken required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *  제목과 내용을 작성하여 문의글을 작성합니다   사진 전송 시 헤더에  Cache-Control 값이 no-cache,no-store,must-revalidate 되어 있어야 합니다  (Completed)
     * @summary 고객센터의 문의글 작성
     * @param {InquiryCreateRequest} inquiryCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    newInquiry: async (
      inquiryCreateRequest: InquiryCreateRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'inquiryCreateRequest' is not null or undefined
      assertParamExists(
        "newInquiry",
        "inquiryCreateRequest",
        inquiryCreateRequest
      );
      const localVarPath = `/inquiry`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication accessToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication refreshToken required

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        inquiryCreateRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 프론트는 이 URL로 리디렉션하여 OAuth2 로그인을 시작합니다. 예: /oauth2/authorization/google
     * @summary OAuth2 로그인 진입점 URL 안내
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    oauth2Urls: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/users/authorization-info`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication accessToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication refreshToken required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * OAuth 추가 회원가입(Completed)
     * @summary 회원가입
     * @param {OAuthSignUpRequest} oAuthSignUpRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    oauthSignup: async (
      oAuthSignUpRequest: OAuthSignUpRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'oAuthSignUpRequest' is not null or undefined
      assertParamExists(
        "oauthSignup",
        "oAuthSignUpRequest",
        oAuthSignUpRequest
      );
      const localVarPath = `/users/signup/oauth`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication accessToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication refreshToken required

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        oAuthSignUpRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ownerTest: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/owner/test`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication accessToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication refreshToken required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 맛집 탐험 파티의 예약을 위한 예약금을 지불합니다.(Completed)
     * @summary 파티 예약금 지불
     * @param {number} partyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    payPartyFee: async (
      partyId: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'partyId' is not null or undefined
      assertParamExists("payPartyFee", "partyId", partyId);
      const localVarPath = `/parties/{partyId}/pay`.replace(
        `{${"partyId"}}`,
        encodeURIComponent(String(partyId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication accessToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication refreshToken required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 맛집 탐험 파티를 참여를 취소합니다.(Completed)
     * @summary 파티 탈퇴
     * @param {number} partyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    quitParty: async (
      partyId: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'partyId' is not null or undefined
      assertParamExists("quitParty", "partyId", partyId);
      const localVarPath = `/parties/{partyId}/quit`.replace(
        `{${"partyId"}}`,
        encodeURIComponent(String(partyId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication accessToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication refreshToken required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 맛집 탐험 파티에서 파티원을 강제 퇴장시킵니다.(Completed)
     * @summary 파티 강퇴
     * @param {number} partyId
     * @param {number} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    quitParty1: async (
      partyId: number,
      userId: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'partyId' is not null or undefined
      assertParamExists("quitParty1", "partyId", partyId);
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("quitParty1", "userId", userId);
      const localVarPath = `/parties/{partyId}/kick/{userId}`
        .replace(`{${"partyId"}}`, encodeURIComponent(String(partyId)))
        .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication accessToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication refreshToken required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 쿠키의 리프레시 토큰을 이용해 새로운 액세스 토큰을 재발급합니다.
     * @summary 액세스 토큰 재발급
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshToken: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/users/reissue-token`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication accessToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication refreshToken required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * reservationId에 해당하는 예약을 REFUSED 상태로 변경한다. (Completed)
     * @summary 예약 거절
     * @param {number} reservationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refuseReservation: async (
      reservationId: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'reservationId' is not null or undefined
      assertParamExists("refuseReservation", "reservationId", reservationId);
      const localVarPath = `/reservations/{reservationId}/refuse`.replace(
        `{${"reservationId"}}`,
        encodeURIComponent(String(reservationId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication accessToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication refreshToken required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 1. 결제 요청 전에 주문 정보를 서버에 저장    결제하기 버튼을 누를 때 (실제 결제 요청 api 보내기 전) 호출하면 됩니다. orderId는 클라이언트에서 임의의 랜덤한 숫자로 제작합니다. 2. orderId, amount 저장 3. 이후 결제 요청 / 결제 성공 시 서버에 저장된 값과 비교  → 변조 방지, 악의적인 금액 조작 차단  (Completed)
     * @summary 주문 정보 임시 저장 api
     * @param {OrderSaveRequest} orderSaveRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveOrder: async (
      orderSaveRequest: OrderSaveRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'orderSaveRequest' is not null or undefined
      assertParamExists("saveOrder", "orderSaveRequest", orderSaveRequest);
      const localVarPath = `/payment/order`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication accessToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication refreshToken required

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        orderSaveRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 폼 로그인 회원가입(Completed)
     * @summary 회원가입
     * @param {SignUpRequest} signUpRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signup: async (
      signUpRequest: SignUpRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'signUpRequest' is not null or undefined
      assertParamExists("signup", "signUpRequest", signUpRequest);
      const localVarPath = `/users/signup`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication accessToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication refreshToken required

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        signUpRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 로그인한 사용자의 마이페이지 정보를 수정합니다.(Completed)
     * @summary 내 정보 수정
     * @param {MyInfoUpdateRequest} myInfoUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateMyInfo: async (
      myInfoUpdateRequest: MyInfoUpdateRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'myInfoUpdateRequest' is not null or undefined
      assertParamExists(
        "updateMyInfo",
        "myInfoUpdateRequest",
        myInfoUpdateRequest
      );
      const localVarPath = `/users/my-page`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication accessToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication refreshToken required

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        myInfoUpdateRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 자신이 가진 식당 정보를 수정합니다. (Completed)
     * @summary 사장 식당 정보 수정
     * @param {number} shopId
     * @param {ShopUpdateRequest} shopUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateShop: async (
      shopId: number,
      shopUpdateRequest: ShopUpdateRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'shopId' is not null or undefined
      assertParamExists("updateShop", "shopId", shopId);
      // verify required parameter 'shopUpdateRequest' is not null or undefined
      assertParamExists("updateShop", "shopUpdateRequest", shopUpdateRequest);
      const localVarPath = `/owner/shops/{shopId}`.replace(
        `{${"shopId"}}`,
        encodeURIComponent(String(shopId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication accessToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication refreshToken required

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        shopUpdateRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userTest: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/test`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication accessToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication refreshToken required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * APIApi - functional programming interface
 * @export
 */
export const APIApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = APIApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminTest(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.adminTest(
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APIApi.adminTest"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * reservationId에 해당하는 예약을 CANCELLED 상태로 변경한다. (Completed)
     * @summary 예약 취소
     * @param {number} reservationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async cancelReservation(
      reservationId: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<BaseResponseVoid>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.cancelReservation(
          reservationId,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APIApi.cancelReservation"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 모집중인 파티를 모집종료 상태로 변경합니다.(Completed)
     * @summary 파티 모집 완료 상태 변경
     * @param {number} partyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async completeParty(
      partyId: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<BaseResponseVoid>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.completeParty(
        partyId,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APIApi.completeParty"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 결제 성공 시 (WidgetSuccess로 이동할 때) 이 api를 호출해서 최종 결제 승인 및 저장을 실행합니다. 이 api 에서 에러가 발생할 시 fail path로 리다이렉트합니다. (Completed)
     * @summary 결제 승인 api
     * @param {TossPaymentConfirmRequest} tossPaymentConfirmRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async confirm(
      tossPaymentConfirmRequest: TossPaymentConfirmRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<BaseResponsePaymentSuccessResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.confirm(
        tossPaymentConfirmRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APIApi.confirm"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * reservationId에 해당하는 예약을 CONFIRMED 상태로 변경한다. (Completed)
     * @summary 예약 수락
     * @param {number} reservationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async confirmReservation(
      reservationId: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<BaseResponseVoid>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.confirmReservation(
          reservationId,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APIApi.confirmReservation"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 특정 모임에 댓글을 작성합니다.(Completed)
     * @summary 댓글 작성
     * @param {number} partyId
     * @param {CommentCreateRequest} commentCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createComment(
      partyId: number,
      commentCreateRequest: CommentCreateRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<BaseResponseVoid>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createComment(
        partyId,
        commentCreateRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APIApi.createComment"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 특정 모임에 댓글을 작성합니다.(Completed)
     * @summary 고객센터 댓글 작성
     * @param {number} inquiryId
     * @param {CommentCreateRequest} commentCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createInquiryComment(
      inquiryId: number,
      commentCreateRequest: CommentCreateRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<BaseResponseVoid>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createInquiryComment(
          inquiryId,
          commentCreateRequest,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APIApi.createInquiryComment"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 맛집 탐험 파티 모집 게시글을 작성합니다.(Completed)
     * @summary 파티 생성
     * @param {PartyCreateRequest} partyCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createParty(
      partyCreateRequest: PartyCreateRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<BaseResponseVoid>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createParty(
        partyCreateRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APIApi.createParty"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * shopId에 해당하는 식당에 예약을 생성한다. 파티 예약인 경우 partyId를 쿼리 파라미터로 전달해야 한다.(Completed)
     * @summary 예약 생성
     * @param {number} shopId
     * @param {CreateReservationRequest} createReservationRequest
     * @param {} [UNKNOWN_PARAMETER_NAME] 파티 ID (선택값). 파티 예약일 경우 전달.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createReservation(
      shopId: number,
      createReservationRequest: CreateReservationRequest,
      UNKNOWN_PARAMETER_NAME?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<CreateReservationResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createReservation(
          shopId,
          createReservationRequest,
          UNKNOWN_PARAMETER_NAME,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APIApi.createReservation"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 리뷰를 작성합니다.(Completed)
     * @summary 리뷰 작성
     * @param {ReviewCreateRequest} reviewCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createReview(
      reviewCreateRequest: ReviewCreateRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<BaseResponsePreSignedUrlListResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createReview(
        reviewCreateRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APIApi.createReview"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 사용자는 새로운 식당을 생성합니다.(Completed)  사진 전송 시 헤더에 Cache-Control 값이 no-cache,no-store,must-revalidate 되어 있어야 합니다
     * @summary 식당 생성
     * @param {ShopCreateRequest} shopCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createShop(
      shopCreateRequest: ShopCreateRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<BaseResponsePreSignedUrlListResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createShop(
        shopCreateRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APIApi.createShop"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 특정 댓글을 삭제합니다.(Completed)
     * @summary 댓글 삭제
     * @param {number} commentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteComment(
      commentId: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteComment(
        commentId,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APIApi.deleteComment"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 맛집 탐험 파티 게시글을 삭제합니다.(Completed)
     * @summary 파티 삭제
     * @param {number} partyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteParty(
      partyId: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteParty(
        partyId,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APIApi.deleteParty"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 프로필 수정 작업 중 예외 발생으로 업로드된 이미지를 삭제합니다.(Completed)
     * @summary 프로필 이미지 삭제
     * @param {DeleteProfileRequest} deleteProfileRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteProfile(
      deleteProfileRequest: DeleteProfileRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProfile(
        deleteProfileRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APIApi.deleteProfile"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 특정 리뷰를 삭제합니다.(Completed)
     * @summary 리뷰 삭제
     * @param {number} reviewId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteReview(
      reviewId: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteReview(
        reviewId,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APIApi.deleteReview"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 회원 탈퇴 기능(Inprogress)
     * @summary 회원탈퇴
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteUser(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APIApi.deleteUser"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 문의글 전체를 조회합니다. (Completed)
     * @summary 고객센터의 문의글 전체 조회
     * @param {number} [cursor]
     * @param {number} [size]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllInquiry(
      cursor?: number,
      size?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<BaseResponseInquiryAllGetResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAllInquiry(
        cursor,
        size,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APIApi.getAllInquiry"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 특정 모임의 댓글 목록을 조회합니다.(Completed)
     * @summary 댓글 조회
     * @param {number} partyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getComments(
      partyId: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<BaseResponseListCommentResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getComments(
        partyId,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APIApi.getComments"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 사용자가 특정 식당의 상세 정보를 조회합니다. 식당 등록 상태가 APPROVED인 식당들만 조회 가능 (Completed)
     * @summary 식당 상세 조회
     * @param {number} shopId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDetailShop(
      shopId: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<BaseResponseShopDetailResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getDetailShop(
        shopId,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APIApi.getDetailShop"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 자신이 가진 식당의 상세 정보를 조회합니다. (Completed)
     * @summary 사장의 식당 상세 조회
     * @param {number} shopId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDetailShopOwner(
      shopId: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<BaseResponseShopOwnerDetailResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getDetailShopOwner(shopId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APIApi.getDetailShopOwner"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 특정 모임의 댓글 목록을 조회합니다.(Completed)
     * @summary 고객센터 댓글 조회
     * @param {number} inquiryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getInquiryComments(
      inquiryId: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<BaseResponseListCommentResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getInquiryComments(inquiryId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APIApi.getInquiryComments"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 로그인한 사용자의 마이페이지 정보를 조회합니다.(Completed)
     * @summary 내 정보 조회
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMyInfo(
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<BaseResponseMyInfoResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getMyInfo(
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APIApi.getMyInfo"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 로그인한 사용자의 파티 목록을 커서 기반 페이징 방식으로 조회합니다.(Completed)
     * @summary 내 파티 정보 조회
     * @param {number} [size]
     * @param {number} [cursor]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMyParties(
      size?: number,
      cursor?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<BaseResponseMyPartyPageResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getMyParties(
        size,
        cursor,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APIApi.getMyParties"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 로그인한 사용자의 예약 목록을 커서 기반 페이징 방식으로 조회합니다.(Completed)
     * @summary 내 예약 정보 조회
     * @param {number} [size]
     * @param {number} [cursor]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMyReservations(
      size?: number,
      cursor?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<BaseResponseMyReservationPageResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getMyReservations(
          size,
          cursor,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APIApi.getMyReservations"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 로그인한 사용자가 작성한 리뷰 목록을 커서 기반 페이징 방식으로 조회합니다.(Completed)
     * @summary 내 리뷰 정보 조회
     * @param {number} [size]
     * @param {number} [cursor]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMyReviews(
      size?: number,
      cursor?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<BaseResponseMyReviewPageResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getMyReviews(
        size,
        cursor,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APIApi.getMyReviews"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 본인이 작성한 경우이거나 관리자의 경우에만 조회가 가능합니다. (Completed)
     * @summary 자신이 작성한 고객센터의 문의글 하나 상세 조회
     * @param {number} inquiryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getOneInquiry(
      inquiryId: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<BaseResponseInquiryOneGetResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getOneInquiry(
        inquiryId,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APIApi.getOneInquiry"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 사장 한명이 가진 식당들 리스트들을 조회합니다. 승인 여부 상태와 상관없이 조회 (Completed)
     * @summary 사장이 가진 식당들 조회
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getOwnerShops(
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<BaseResponseOwnerShopsList>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getOwnerShops(
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APIApi.getOwnerShops"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 파티 상태, 위치, 음식 카테고리로 필터링한 파티 게시글 목록을 조회합니다. (Completed)  예시 /parties?status=RECRUITING&minAge=10&categories=CHICKEN&categories=JAPANESE  | 필드 명     | 자료형    | 필수 여부  | 설명                                            | 기본값                   | |------------|---------|-----------|-------------------------------------------------|------------------------| | status     | string  | Optional  | 파티 상태                                        | 전체                    | | gender     | string  | Optional  | 모집 성별 조건(A일 시 성별 무관인 파티만 조회합니다.)   |  전체                   | | minAge     | int     | Optional  | 모집 최소 나이                                    | 전체                    | | maxAge     | int     | Optional  | 모집 최대 나이                                    | 전체                    | | location   | string  | Optional  | 시/도 단위 파티 위치                               | 전체                    | | category   | string  | Optional  | 음식 카테고리 (다중 선택 가능)                       | 전체                    | | query      | string  | Optional  | 파티 제목 검색 키워드                               | 전체                    | | cursor       | int  | Optional   | 페이징 마지막 파티 id                               | 첫번째 페이지            |
     * @summary 파티 목록 조회
     * @param {GetPartiesStatusEnum} [status]
     * @param {GetPartiesGenderEnum} [gender]
     * @param {number} [minAge]
     * @param {number} [maxAge]
     * @param {string} [location]
     * @param {Array<GetPartiesCategoriesEnum>} [categories]
     * @param {string} [query]
     * @param {number} [cursor]
     * @param {number} [size]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getParties(
      status?: GetPartiesStatusEnum,
      gender?: GetPartiesGenderEnum,
      minAge?: number,
      maxAge?: number,
      location?: string,
      categories?: Array<GetPartiesCategoriesEnum>,
      query?: string,
      cursor?: number,
      size?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<BaseResponsePartyScrollResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getParties(
        status,
        gender,
        minAge,
        maxAge,
        location,
        categories,
        query,
        cursor,
        size,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APIApi.getParties"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 맛집 탐험 파티 상세 정보를 조회합니다.(Completed)
     * @summary 파티 상세 조회
     * @param {number} partyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPartyDetail(
      partyId: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<BaseResponsePartyDetailResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPartyDetail(
        partyId,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APIApi.getPartyDetail"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 맛집 탐험 파티원 목록을 조회합니다.(Completed)
     * @summary 파티원 목록 조회
     * @param {number} partyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPartyMembers(
      partyId: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<BaseResponseListPartyMemberResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPartyMembers(
        partyId,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APIApi.getPartyMembers"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 결제 내역을 스크롤 방식으로 조회합니다. 사용자의 마이페이지 란에서 조회 가능합니다. (Completed)
     * @summary 결제 내역 조회 api
     * @param {number} [size]
     * @param {number} [cursor]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPaymentHistories(
      size?: number,
      cursor?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<BaseResponsePaymentScrollResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getPaymentHistories(
          size,
          cursor,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APIApi.getPaymentHistories"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * APPROVED(승인) 또는 REJECTED(거절) (Completed)
     * @summary 관리자가 식당 등록에 대한 요청을 승인 또는 거절
     * @param {number} shopId
     * @param {ApproveRequest} approveRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPendingShop(
      shopId: number,
      approveRequest: ApproveRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPendingShop(
        shopId,
        approveRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APIApi.getPendingShop"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 관리자는 등록을 원하는 식당 리스트를 볼 수 있습니다. (Completed)
     * @summary 관리자가 pending 상태인 식당들 리스트를 가져옴
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPendingShop1(
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<BaseResponseGetAllPendingShopListResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPendingShop1(
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APIApi.getPendingShop1"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 내 정보 수정 항목 중 프로필 이미지를 업로드하기 위한 pre-signed url을 생성합니다.(Completed)
     * @summary 프로필 이미지 업로드를 위한 pre-signed url 생성
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getProfilePresignedUrl(
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<BaseResponsePreSignedUrlResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getProfilePresignedUrl(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APIApi.getProfilePresignedUrl"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 식당의 예약 목록을 필터와 커서 기반으로 조회한다.(Completed)
     * @summary 식당 예약 목록 조회
     * @param {GetReservationsFilterEnum} [filter]
     * @param {number} [cursor]
     * @param {number} [size]
     * @param {number} [shopId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getReservations(
      filter?: GetReservationsFilterEnum,
      cursor?: number,
      size?: number,
      shopId?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ReservationListResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getReservations(
        filter,
        cursor,
        size,
        shopId,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APIApi.getReservations"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 특정 가게의 리뷰 목록을 조회합니다.(Completed)
     * @summary 리뷰 조회
     * @param {number} shopId
     * @param {number} [cursor]
     * @param {number} [size]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getReviews(
      shopId: number,
      cursor?: number,
      size?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<BaseResponseReviewPageResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getReviews(
        shopId,
        cursor,
        size,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APIApi.getReviews"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 관리자는 식당에 대한 정보를 볼 수 있습니다. (식당의 등록 상태가 뭐든 볼 수 있음) (Completed)
     * @summary 관리자가 식당에 대한 정보를 봄
     * @param {number} shopId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getShopAdminDetail(
      shopId: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<BaseResponseShopAdminDetailResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getShopAdminDetail(shopId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APIApi.getShopAdminDetail"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 일반 사용자가 위치 기반으로 식당 목록을 조회합니다. (식당 상태가 APPROVED인 식당들만 조회 가능) (Completed)  반경은 m 단위로 주시면 되며 ->  3km (3000) 만약 사용자가 자신의 위치를 허용한다면 latitude과 longitude에 사용자 위도 경도, 원하는 범위를 넣어서 요청을 보내고 그렇지 않는다면 기본값으론 종로구 좌표에 3km 범위 식당을 가져옵니다  예시 /shops?radius=1000000&sort=rating  | 필드 명     | 자료형  | 필수 여부 | 설명                   | 기본값           | |------------|---------|-----------|-------------------------|------------------| | latitude   | double  | Required  | 사용자 위치의 위도         | 37.5724          | | longitude  | double  | Required  | 사용자 위치의 경도         | 126.9794         | | radius     | double  | Optional  | 검색 반경 (단위: m)       | 3000.0           | | category   | string  | Optional  | 음식 카테고리             | 전체             | | sort       | string  | Optional  | 정렬 기준 (근처순, 평점순) | 근처 순(distance) |
     * @summary 식당 목록 조회
     * @param {number} [latitude]
     * @param {number} [longitude]
     * @param {number} [radius]
     * @param {Array<GetShopsCategoryEnum>} [category]
     * @param {string} [sort]
     * @param {number} [cursor]
     * @param {number} [size]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getShops(
      latitude?: number,
      longitude?: number,
      radius?: number,
      category?: Array<GetShopsCategoryEnum>,
      sort?: string,
      cursor?: number,
      size?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<BaseResponseShopsResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getShops(
        latitude,
        longitude,
        radius,
        category,
        sort,
        cursor,
        size,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APIApi.getShops"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 키워드로 식당을 검색합니다.정렬기준: NAME, CREATED_AT, RATING  (식당 상태가 APPROVED인 식당들만 조회 가능)(Completed)
     * @summary 식당 검색
     * @param {string} [query]
     * @param {GetShopsBySearchSortEnum} [sort]
     * @param {string} [cursor]
     * @param {number} [size]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getShopsBySearch(
      query?: string,
      sort?: GetShopsBySearchSortEnum,
      cursor?: string,
      size?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<BaseResponseShopPageResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getShopsBySearch(
          query,
          sort,
          cursor,
          size,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APIApi.getShopsBySearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 맛집 탐험 파티를 참여합니다.(Completed)
     * @summary 파티 참여
     * @param {number} partyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async joinParty(
      partyId: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<BaseResponseVoid>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.joinParty(
        partyId,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APIApi.joinParty"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 폼 로그인으로 로그인합니다. 성공 시 액세스 토큰은 헤더, 리프레시 토큰은 쿠키에 포함됩니다.(Completed)
     * @summary Form 로그인
     * @param {LoginRequest} loginRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async login(
      loginRequest: LoginRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<BaseResponseVoid>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.login(
        loginRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APIApi.login"]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 쿠키의 리프레시 토큰을 무효화하고 로그아웃 처리합니다.
     * @summary 로그아웃
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async logout(
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<BaseResponseVoid>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APIApi.logout"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *  제목과 내용을 작성하여 문의글을 작성합니다   사진 전송 시 헤더에  Cache-Control 값이 no-cache,no-store,must-revalidate 되어 있어야 합니다  (Completed)
     * @summary 고객센터의 문의글 작성
     * @param {InquiryCreateRequest} inquiryCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async newInquiry(
      inquiryCreateRequest: InquiryCreateRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<BaseResponsePreSignedUrlListResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.newInquiry(
        inquiryCreateRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APIApi.newInquiry"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 프론트는 이 URL로 리디렉션하여 OAuth2 로그인을 시작합니다. 예: /oauth2/authorization/google
     * @summary OAuth2 로그인 진입점 URL 안내
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async oauth2Urls(
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: string }>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.oauth2Urls(
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APIApi.oauth2Urls"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * OAuth 추가 회원가입(Completed)
     * @summary 회원가입
     * @param {OAuthSignUpRequest} oAuthSignUpRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async oauthSignup(
      oAuthSignUpRequest: OAuthSignUpRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<BaseResponseVoid>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.oauthSignup(
        oAuthSignUpRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APIApi.oauthSignup"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ownerTest(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.ownerTest(
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APIApi.ownerTest"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 맛집 탐험 파티의 예약을 위한 예약금을 지불합니다.(Completed)
     * @summary 파티 예약금 지불
     * @param {number} partyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async payPartyFee(
      partyId: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.payPartyFee(
        partyId,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APIApi.payPartyFee"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 맛집 탐험 파티를 참여를 취소합니다.(Completed)
     * @summary 파티 탈퇴
     * @param {number} partyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async quitParty(
      partyId: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.quitParty(
        partyId,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APIApi.quitParty"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 맛집 탐험 파티에서 파티원을 강제 퇴장시킵니다.(Completed)
     * @summary 파티 강퇴
     * @param {number} partyId
     * @param {number} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async quitParty1(
      partyId: number,
      userId: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<BaseResponseVoid>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.quitParty1(
        partyId,
        userId,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APIApi.quitParty1"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 쿠키의 리프레시 토큰을 이용해 새로운 액세스 토큰을 재발급합니다.
     * @summary 액세스 토큰 재발급
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async refreshToken(
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<BaseResponseAccessTokenResponseDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.refreshToken(
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APIApi.refreshToken"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * reservationId에 해당하는 예약을 REFUSED 상태로 변경한다. (Completed)
     * @summary 예약 거절
     * @param {number} reservationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async refuseReservation(
      reservationId: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<BaseResponseVoid>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.refuseReservation(
          reservationId,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APIApi.refuseReservation"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 1. 결제 요청 전에 주문 정보를 서버에 저장    결제하기 버튼을 누를 때 (실제 결제 요청 api 보내기 전) 호출하면 됩니다. orderId는 클라이언트에서 임의의 랜덤한 숫자로 제작합니다. 2. orderId, amount 저장 3. 이후 결제 요청 / 결제 성공 시 서버에 저장된 값과 비교  → 변조 방지, 악의적인 금액 조작 차단  (Completed)
     * @summary 주문 정보 임시 저장 api
     * @param {OrderSaveRequest} orderSaveRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async saveOrder(
      orderSaveRequest: OrderSaveRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<BaseResponseVoid>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.saveOrder(
        orderSaveRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APIApi.saveOrder"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 폼 로그인 회원가입(Completed)
     * @summary 회원가입
     * @param {SignUpRequest} signUpRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async signup(
      signUpRequest: SignUpRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<BaseResponseVoid>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.signup(
        signUpRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APIApi.signup"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 로그인한 사용자의 마이페이지 정보를 수정합니다.(Completed)
     * @summary 내 정보 수정
     * @param {MyInfoUpdateRequest} myInfoUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateMyInfo(
      myInfoUpdateRequest: MyInfoUpdateRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<BaseResponseVoid>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateMyInfo(
        myInfoUpdateRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APIApi.updateMyInfo"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 자신이 가진 식당 정보를 수정합니다. (Completed)
     * @summary 사장 식당 정보 수정
     * @param {number} shopId
     * @param {ShopUpdateRequest} shopUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateShop(
      shopId: number,
      shopUpdateRequest: ShopUpdateRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<BaseResponsePreSignedUrlListResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateShop(
        shopId,
        shopUpdateRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APIApi.updateShop"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userTest(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userTest(
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APIApi.userTest"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * APIApi - factory interface
 * @export
 */
export const APIApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = APIApiFp(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminTest(options?: RawAxiosRequestConfig): AxiosPromise<string> {
      return localVarFp
        .adminTest(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * reservationId에 해당하는 예약을 CANCELLED 상태로 변경한다. (Completed)
     * @summary 예약 취소
     * @param {number} reservationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelReservation(
      reservationId: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponseVoid> {
      return localVarFp
        .cancelReservation(reservationId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 모집중인 파티를 모집종료 상태로 변경합니다.(Completed)
     * @summary 파티 모집 완료 상태 변경
     * @param {number} partyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    completeParty(
      partyId: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponseVoid> {
      return localVarFp
        .completeParty(partyId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 결제 성공 시 (WidgetSuccess로 이동할 때) 이 api를 호출해서 최종 결제 승인 및 저장을 실행합니다. 이 api 에서 에러가 발생할 시 fail path로 리다이렉트합니다. (Completed)
     * @summary 결제 승인 api
     * @param {TossPaymentConfirmRequest} tossPaymentConfirmRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    confirm(
      tossPaymentConfirmRequest: TossPaymentConfirmRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponsePaymentSuccessResponse> {
      return localVarFp
        .confirm(tossPaymentConfirmRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * reservationId에 해당하는 예약을 CONFIRMED 상태로 변경한다. (Completed)
     * @summary 예약 수락
     * @param {number} reservationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    confirmReservation(
      reservationId: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponseVoid> {
      return localVarFp
        .confirmReservation(reservationId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 특정 모임에 댓글을 작성합니다.(Completed)
     * @summary 댓글 작성
     * @param {number} partyId
     * @param {CommentCreateRequest} commentCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createComment(
      partyId: number,
      commentCreateRequest: CommentCreateRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponseVoid> {
      return localVarFp
        .createComment(partyId, commentCreateRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 특정 모임에 댓글을 작성합니다.(Completed)
     * @summary 고객센터 댓글 작성
     * @param {number} inquiryId
     * @param {CommentCreateRequest} commentCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createInquiryComment(
      inquiryId: number,
      commentCreateRequest: CommentCreateRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponseVoid> {
      return localVarFp
        .createInquiryComment(inquiryId, commentCreateRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 맛집 탐험 파티 모집 게시글을 작성합니다.(Completed)
     * @summary 파티 생성
     * @param {PartyCreateRequest} partyCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createParty(
      partyCreateRequest: PartyCreateRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponseVoid> {
      return localVarFp
        .createParty(partyCreateRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * shopId에 해당하는 식당에 예약을 생성한다. 파티 예약인 경우 partyId를 쿼리 파라미터로 전달해야 한다.(Completed)
     * @summary 예약 생성
     * @param {number} shopId
     * @param {CreateReservationRequest} createReservationRequest
     * @param {} [UNKNOWN_PARAMETER_NAME] 파티 ID (선택값). 파티 예약일 경우 전달.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createReservation(
      shopId: number,
      createReservationRequest: CreateReservationRequest,
      UNKNOWN_PARAMETER_NAME?: number | undefined,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<CreateReservationResponse> {
      return localVarFp
        .createReservation(
          shopId,
          createReservationRequest,
          UNKNOWN_PARAMETER_NAME,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * 리뷰를 작성합니다.(Completed)
     * @summary 리뷰 작성
     * @param {ReviewCreateRequest} reviewCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createReview(
      reviewCreateRequest: ReviewCreateRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponsePreSignedUrlListResponse> {
      return localVarFp
        .createReview(reviewCreateRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 사용자는 새로운 식당을 생성합니다.(Completed)  사진 전송 시 헤더에 Cache-Control 값이 no-cache,no-store,must-revalidate 되어 있어야 합니다
     * @summary 식당 생성
     * @param {ShopCreateRequest} shopCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createShop(
      shopCreateRequest: ShopCreateRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponsePreSignedUrlListResponse> {
      return localVarFp
        .createShop(shopCreateRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 특정 댓글을 삭제합니다.(Completed)
     * @summary 댓글 삭제
     * @param {number} commentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteComment(
      commentId: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .deleteComment(commentId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 맛집 탐험 파티 게시글을 삭제합니다.(Completed)
     * @summary 파티 삭제
     * @param {number} partyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteParty(
      partyId: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .deleteParty(partyId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 프로필 수정 작업 중 예외 발생으로 업로드된 이미지를 삭제합니다.(Completed)
     * @summary 프로필 이미지 삭제
     * @param {DeleteProfileRequest} deleteProfileRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteProfile(
      deleteProfileRequest: DeleteProfileRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .deleteProfile(deleteProfileRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 특정 리뷰를 삭제합니다.(Completed)
     * @summary 리뷰 삭제
     * @param {number} reviewId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteReview(
      reviewId: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .deleteReview(reviewId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 회원 탈퇴 기능(Inprogress)
     * @summary 회원탈퇴
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser(options?: RawAxiosRequestConfig): AxiosPromise<void> {
      return localVarFp
        .deleteUser(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 문의글 전체를 조회합니다. (Completed)
     * @summary 고객센터의 문의글 전체 조회
     * @param {number} [cursor]
     * @param {number} [size]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllInquiry(
      cursor?: number,
      size?: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponseInquiryAllGetResponse> {
      return localVarFp
        .getAllInquiry(cursor, size, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 특정 모임의 댓글 목록을 조회합니다.(Completed)
     * @summary 댓글 조회
     * @param {number} partyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getComments(
      partyId: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponseListCommentResponse> {
      return localVarFp
        .getComments(partyId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 사용자가 특정 식당의 상세 정보를 조회합니다. 식당 등록 상태가 APPROVED인 식당들만 조회 가능 (Completed)
     * @summary 식당 상세 조회
     * @param {number} shopId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDetailShop(
      shopId: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponseShopDetailResponse> {
      return localVarFp
        .getDetailShop(shopId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 자신이 가진 식당의 상세 정보를 조회합니다. (Completed)
     * @summary 사장의 식당 상세 조회
     * @param {number} shopId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDetailShopOwner(
      shopId: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponseShopOwnerDetailResponse> {
      return localVarFp
        .getDetailShopOwner(shopId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 특정 모임의 댓글 목록을 조회합니다.(Completed)
     * @summary 고객센터 댓글 조회
     * @param {number} inquiryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInquiryComments(
      inquiryId: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponseListCommentResponse> {
      return localVarFp
        .getInquiryComments(inquiryId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 로그인한 사용자의 마이페이지 정보를 조회합니다.(Completed)
     * @summary 내 정보 조회
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMyInfo(
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponseMyInfoResponse> {
      return localVarFp
        .getMyInfo(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 로그인한 사용자의 파티 목록을 커서 기반 페이징 방식으로 조회합니다.(Completed)
     * @summary 내 파티 정보 조회
     * @param {number} [size]
     * @param {number} [cursor]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMyParties(
      size?: number,
      cursor?: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponseMyPartyPageResponse> {
      return localVarFp
        .getMyParties(size, cursor, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 로그인한 사용자의 예약 목록을 커서 기반 페이징 방식으로 조회합니다.(Completed)
     * @summary 내 예약 정보 조회
     * @param {number} [size]
     * @param {number} [cursor]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMyReservations(
      size?: number,
      cursor?: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponseMyReservationPageResponse> {
      return localVarFp
        .getMyReservations(size, cursor, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 로그인한 사용자가 작성한 리뷰 목록을 커서 기반 페이징 방식으로 조회합니다.(Completed)
     * @summary 내 리뷰 정보 조회
     * @param {number} [size]
     * @param {number} [cursor]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMyReviews(
      size?: number,
      cursor?: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponseMyReviewPageResponse> {
      return localVarFp
        .getMyReviews(size, cursor, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 본인이 작성한 경우이거나 관리자의 경우에만 조회가 가능합니다. (Completed)
     * @summary 자신이 작성한 고객센터의 문의글 하나 상세 조회
     * @param {number} inquiryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOneInquiry(
      inquiryId: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponseInquiryOneGetResponse> {
      return localVarFp
        .getOneInquiry(inquiryId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 사장 한명이 가진 식당들 리스트들을 조회합니다. 승인 여부 상태와 상관없이 조회 (Completed)
     * @summary 사장이 가진 식당들 조회
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOwnerShops(
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponseOwnerShopsList> {
      return localVarFp
        .getOwnerShops(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 파티 상태, 위치, 음식 카테고리로 필터링한 파티 게시글 목록을 조회합니다. (Completed)  예시 /parties?status=RECRUITING&minAge=10&categories=CHICKEN&categories=JAPANESE  | 필드 명     | 자료형    | 필수 여부  | 설명                                            | 기본값                   | |------------|---------|-----------|-------------------------------------------------|------------------------| | status     | string  | Optional  | 파티 상태                                        | 전체                    | | gender     | string  | Optional  | 모집 성별 조건(A일 시 성별 무관인 파티만 조회합니다.)   |  전체                   | | minAge     | int     | Optional  | 모집 최소 나이                                    | 전체                    | | maxAge     | int     | Optional  | 모집 최대 나이                                    | 전체                    | | location   | string  | Optional  | 시/도 단위 파티 위치                               | 전체                    | | category   | string  | Optional  | 음식 카테고리 (다중 선택 가능)                       | 전체                    | | query      | string  | Optional  | 파티 제목 검색 키워드                               | 전체                    | | cursor       | int  | Optional   | 페이징 마지막 파티 id                               | 첫번째 페이지            |
     * @summary 파티 목록 조회
     * @param {GetPartiesStatusEnum} [status]
     * @param {GetPartiesGenderEnum} [gender]
     * @param {number} [minAge]
     * @param {number} [maxAge]
     * @param {string} [location]
     * @param {Array<GetPartiesCategoriesEnum>} [categories]
     * @param {string} [query]
     * @param {number} [cursor]
     * @param {number} [size]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getParties(
      status?: GetPartiesStatusEnum,
      gender?: GetPartiesGenderEnum,
      minAge?: number,
      maxAge?: number,
      location?: string,
      categories?: Array<GetPartiesCategoriesEnum>,
      query?: string,
      cursor?: number,
      size?: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponsePartyScrollResponse> {
      return localVarFp
        .getParties(
          status,
          gender,
          minAge,
          maxAge,
          location,
          categories,
          query,
          cursor,
          size,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * 맛집 탐험 파티 상세 정보를 조회합니다.(Completed)
     * @summary 파티 상세 조회
     * @param {number} partyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPartyDetail(
      partyId: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponsePartyDetailResponse> {
      return localVarFp
        .getPartyDetail(partyId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 맛집 탐험 파티원 목록을 조회합니다.(Completed)
     * @summary 파티원 목록 조회
     * @param {number} partyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPartyMembers(
      partyId: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponseListPartyMemberResponse> {
      return localVarFp
        .getPartyMembers(partyId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 결제 내역을 스크롤 방식으로 조회합니다. 사용자의 마이페이지 란에서 조회 가능합니다. (Completed)
     * @summary 결제 내역 조회 api
     * @param {number} [size]
     * @param {number} [cursor]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentHistories(
      size?: number,
      cursor?: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponsePaymentScrollResponse> {
      return localVarFp
        .getPaymentHistories(size, cursor, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * APPROVED(승인) 또는 REJECTED(거절) (Completed)
     * @summary 관리자가 식당 등록에 대한 요청을 승인 또는 거절
     * @param {number} shopId
     * @param {ApproveRequest} approveRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPendingShop(
      shopId: number,
      approveRequest: ApproveRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .getPendingShop(shopId, approveRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 관리자는 등록을 원하는 식당 리스트를 볼 수 있습니다. (Completed)
     * @summary 관리자가 pending 상태인 식당들 리스트를 가져옴
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPendingShop1(
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponseGetAllPendingShopListResponse> {
      return localVarFp
        .getPendingShop1(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 내 정보 수정 항목 중 프로필 이미지를 업로드하기 위한 pre-signed url을 생성합니다.(Completed)
     * @summary 프로필 이미지 업로드를 위한 pre-signed url 생성
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProfilePresignedUrl(
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponsePreSignedUrlResponse> {
      return localVarFp
        .getProfilePresignedUrl(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 식당의 예약 목록을 필터와 커서 기반으로 조회한다.(Completed)
     * @summary 식당 예약 목록 조회
     * @param {GetReservationsFilterEnum} [filter]
     * @param {number} [cursor]
     * @param {number} [size]
     * @param {number} [shopId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReservations(
      filter?: GetReservationsFilterEnum,
      cursor?: number,
      size?: number,
      shopId?: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ReservationListResponse> {
      return localVarFp
        .getReservations(filter, cursor, size, shopId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 특정 가게의 리뷰 목록을 조회합니다.(Completed)
     * @summary 리뷰 조회
     * @param {number} shopId
     * @param {number} [cursor]
     * @param {number} [size]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReviews(
      shopId: number,
      cursor?: number,
      size?: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponseReviewPageResponse> {
      return localVarFp
        .getReviews(shopId, cursor, size, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 관리자는 식당에 대한 정보를 볼 수 있습니다. (식당의 등록 상태가 뭐든 볼 수 있음) (Completed)
     * @summary 관리자가 식당에 대한 정보를 봄
     * @param {number} shopId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getShopAdminDetail(
      shopId: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponseShopAdminDetailResponse> {
      return localVarFp
        .getShopAdminDetail(shopId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 일반 사용자가 위치 기반으로 식당 목록을 조회합니다. (식당 상태가 APPROVED인 식당들만 조회 가능) (Completed)  반경은 m 단위로 주시면 되며 ->  3km (3000) 만약 사용자가 자신의 위치를 허용한다면 latitude과 longitude에 사용자 위도 경도, 원하는 범위를 넣어서 요청을 보내고 그렇지 않는다면 기본값으론 종로구 좌표에 3km 범위 식당을 가져옵니다  예시 /shops?radius=1000000&sort=rating  | 필드 명     | 자료형  | 필수 여부 | 설명                   | 기본값           | |------------|---------|-----------|-------------------------|------------------| | latitude   | double  | Required  | 사용자 위치의 위도         | 37.5724          | | longitude  | double  | Required  | 사용자 위치의 경도         | 126.9794         | | radius     | double  | Optional  | 검색 반경 (단위: m)       | 3000.0           | | category   | string  | Optional  | 음식 카테고리             | 전체             | | sort       | string  | Optional  | 정렬 기준 (근처순, 평점순) | 근처 순(distance) |
     * @summary 식당 목록 조회
     * @param {number} [latitude]
     * @param {number} [longitude]
     * @param {number} [radius]
     * @param {Array<GetShopsCategoryEnum>} [category]
     * @param {string} [sort]
     * @param {number} [cursor]
     * @param {number} [size]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getShops(
      latitude?: number,
      longitude?: number,
      radius?: number,
      category?: Array<GetShopsCategoryEnum>,
      sort?: string,
      cursor?: number,
      size?: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponseShopsResponse> {
      return localVarFp
        .getShops(
          latitude,
          longitude,
          radius,
          category,
          sort,
          cursor,
          size,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * 키워드로 식당을 검색합니다.정렬기준: NAME, CREATED_AT, RATING  (식당 상태가 APPROVED인 식당들만 조회 가능)(Completed)
     * @summary 식당 검색
     * @param {string} [query]
     * @param {GetShopsBySearchSortEnum} [sort]
     * @param {string} [cursor]
     * @param {number} [size]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getShopsBySearch(
      query?: string,
      sort?: GetShopsBySearchSortEnum,
      cursor?: string,
      size?: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponseShopPageResponse> {
      return localVarFp
        .getShopsBySearch(query, sort, cursor, size, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 맛집 탐험 파티를 참여합니다.(Completed)
     * @summary 파티 참여
     * @param {number} partyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    joinParty(
      partyId: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponseVoid> {
      return localVarFp
        .joinParty(partyId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 폼 로그인으로 로그인합니다. 성공 시 액세스 토큰은 헤더, 리프레시 토큰은 쿠키에 포함됩니다.(Completed)
     * @summary Form 로그인
     * @param {LoginRequest} loginRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    login(
      loginRequest: LoginRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponseVoid> {
      return localVarFp
        .login(loginRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 쿠키의 리프레시 토큰을 무효화하고 로그아웃 처리합니다.
     * @summary 로그아웃
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logout(options?: RawAxiosRequestConfig): AxiosPromise<BaseResponseVoid> {
      return localVarFp
        .logout(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  제목과 내용을 작성하여 문의글을 작성합니다   사진 전송 시 헤더에  Cache-Control 값이 no-cache,no-store,must-revalidate 되어 있어야 합니다  (Completed)
     * @summary 고객센터의 문의글 작성
     * @param {InquiryCreateRequest} inquiryCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    newInquiry(
      inquiryCreateRequest: InquiryCreateRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponsePreSignedUrlListResponse> {
      return localVarFp
        .newInquiry(inquiryCreateRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 프론트는 이 URL로 리디렉션하여 OAuth2 로그인을 시작합니다. 예: /oauth2/authorization/google
     * @summary OAuth2 로그인 진입점 URL 안내
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    oauth2Urls(
      options?: RawAxiosRequestConfig
    ): AxiosPromise<{ [key: string]: string }> {
      return localVarFp
        .oauth2Urls(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * OAuth 추가 회원가입(Completed)
     * @summary 회원가입
     * @param {OAuthSignUpRequest} oAuthSignUpRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    oauthSignup(
      oAuthSignUpRequest: OAuthSignUpRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponseVoid> {
      return localVarFp
        .oauthSignup(oAuthSignUpRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ownerTest(options?: RawAxiosRequestConfig): AxiosPromise<string> {
      return localVarFp
        .ownerTest(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 맛집 탐험 파티의 예약을 위한 예약금을 지불합니다.(Completed)
     * @summary 파티 예약금 지불
     * @param {number} partyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    payPartyFee(
      partyId: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .payPartyFee(partyId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 맛집 탐험 파티를 참여를 취소합니다.(Completed)
     * @summary 파티 탈퇴
     * @param {number} partyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    quitParty(
      partyId: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .quitParty(partyId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 맛집 탐험 파티에서 파티원을 강제 퇴장시킵니다.(Completed)
     * @summary 파티 강퇴
     * @param {number} partyId
     * @param {number} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    quitParty1(
      partyId: number,
      userId: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponseVoid> {
      return localVarFp
        .quitParty1(partyId, userId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 쿠키의 리프레시 토큰을 이용해 새로운 액세스 토큰을 재발급합니다.
     * @summary 액세스 토큰 재발급
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshToken(
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponseAccessTokenResponseDto> {
      return localVarFp
        .refreshToken(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * reservationId에 해당하는 예약을 REFUSED 상태로 변경한다. (Completed)
     * @summary 예약 거절
     * @param {number} reservationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refuseReservation(
      reservationId: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponseVoid> {
      return localVarFp
        .refuseReservation(reservationId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 1. 결제 요청 전에 주문 정보를 서버에 저장    결제하기 버튼을 누를 때 (실제 결제 요청 api 보내기 전) 호출하면 됩니다. orderId는 클라이언트에서 임의의 랜덤한 숫자로 제작합니다. 2. orderId, amount 저장 3. 이후 결제 요청 / 결제 성공 시 서버에 저장된 값과 비교  → 변조 방지, 악의적인 금액 조작 차단  (Completed)
     * @summary 주문 정보 임시 저장 api
     * @param {OrderSaveRequest} orderSaveRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveOrder(
      orderSaveRequest: OrderSaveRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponseVoid> {
      return localVarFp
        .saveOrder(orderSaveRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 폼 로그인 회원가입(Completed)
     * @summary 회원가입
     * @param {SignUpRequest} signUpRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signup(
      signUpRequest: SignUpRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponseVoid> {
      return localVarFp
        .signup(signUpRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 로그인한 사용자의 마이페이지 정보를 수정합니다.(Completed)
     * @summary 내 정보 수정
     * @param {MyInfoUpdateRequest} myInfoUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateMyInfo(
      myInfoUpdateRequest: MyInfoUpdateRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponseVoid> {
      return localVarFp
        .updateMyInfo(myInfoUpdateRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 자신이 가진 식당 정보를 수정합니다. (Completed)
     * @summary 사장 식당 정보 수정
     * @param {number} shopId
     * @param {ShopUpdateRequest} shopUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateShop(
      shopId: number,
      shopUpdateRequest: ShopUpdateRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponsePreSignedUrlListResponse> {
      return localVarFp
        .updateShop(shopId, shopUpdateRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userTest(options?: RawAxiosRequestConfig): AxiosPromise<string> {
      return localVarFp
        .userTest(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * APIApi - object-oriented interface
 * @export
 * @class APIApi
 * @extends {BaseAPI}
 */
export class APIApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIApi
   */
  public adminTest(options?: RawAxiosRequestConfig) {
    return APIApiFp(this.configuration)
      .adminTest(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * reservationId에 해당하는 예약을 CANCELLED 상태로 변경한다. (Completed)
   * @summary 예약 취소
   * @param {number} reservationId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIApi
   */
  public cancelReservation(
    reservationId: number,
    options?: RawAxiosRequestConfig
  ) {
    return APIApiFp(this.configuration)
      .cancelReservation(reservationId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 모집중인 파티를 모집종료 상태로 변경합니다.(Completed)
   * @summary 파티 모집 완료 상태 변경
   * @param {number} partyId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIApi
   */
  public completeParty(partyId: number, options?: RawAxiosRequestConfig) {
    return APIApiFp(this.configuration)
      .completeParty(partyId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 결제 성공 시 (WidgetSuccess로 이동할 때) 이 api를 호출해서 최종 결제 승인 및 저장을 실행합니다. 이 api 에서 에러가 발생할 시 fail path로 리다이렉트합니다. (Completed)
   * @summary 결제 승인 api
   * @param {TossPaymentConfirmRequest} tossPaymentConfirmRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIApi
   */
  public confirm(
    tossPaymentConfirmRequest: TossPaymentConfirmRequest,
    options?: RawAxiosRequestConfig
  ) {
    return APIApiFp(this.configuration)
      .confirm(tossPaymentConfirmRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * reservationId에 해당하는 예약을 CONFIRMED 상태로 변경한다. (Completed)
   * @summary 예약 수락
   * @param {number} reservationId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIApi
   */
  public confirmReservation(
    reservationId: number,
    options?: RawAxiosRequestConfig
  ) {
    return APIApiFp(this.configuration)
      .confirmReservation(reservationId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 특정 모임에 댓글을 작성합니다.(Completed)
   * @summary 댓글 작성
   * @param {number} partyId
   * @param {CommentCreateRequest} commentCreateRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIApi
   */
  public createComment(
    partyId: number,
    commentCreateRequest: CommentCreateRequest,
    options?: RawAxiosRequestConfig
  ) {
    return APIApiFp(this.configuration)
      .createComment(partyId, commentCreateRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 특정 모임에 댓글을 작성합니다.(Completed)
   * @summary 고객센터 댓글 작성
   * @param {number} inquiryId
   * @param {CommentCreateRequest} commentCreateRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIApi
   */
  public createInquiryComment(
    inquiryId: number,
    commentCreateRequest: CommentCreateRequest,
    options?: RawAxiosRequestConfig
  ) {
    return APIApiFp(this.configuration)
      .createInquiryComment(inquiryId, commentCreateRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 맛집 탐험 파티 모집 게시글을 작성합니다.(Completed)
   * @summary 파티 생성
   * @param {PartyCreateRequest} partyCreateRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIApi
   */
  public createParty(
    partyCreateRequest: PartyCreateRequest,
    options?: RawAxiosRequestConfig
  ) {
    return APIApiFp(this.configuration)
      .createParty(partyCreateRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * shopId에 해당하는 식당에 예약을 생성한다. 파티 예약인 경우 partyId를 쿼리 파라미터로 전달해야 한다.(Completed)
   * @summary 예약 생성
   * @param {number} shopId
   * @param {CreateReservationRequest} createReservationRequest
   * @param {} [UNKNOWN_PARAMETER_NAME] 파티 ID (선택값). 파티 예약일 경우 전달.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIApi
   */
  public createReservation(
    shopId: number,
    createReservationRequest: CreateReservationRequest,
    UNKNOWN_PARAMETER_NAME?: number | undefined,
    options?: RawAxiosRequestConfig
  ) {
    return APIApiFp(this.configuration)
      .createReservation(
        shopId,
        createReservationRequest,
        UNKNOWN_PARAMETER_NAME,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 리뷰를 작성합니다.(Completed)
   * @summary 리뷰 작성
   * @param {ReviewCreateRequest} reviewCreateRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIApi
   */
  public createReview(
    reviewCreateRequest: ReviewCreateRequest,
    options?: RawAxiosRequestConfig
  ) {
    return APIApiFp(this.configuration)
      .createReview(reviewCreateRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 사용자는 새로운 식당을 생성합니다.(Completed)  사진 전송 시 헤더에 Cache-Control 값이 no-cache,no-store,must-revalidate 되어 있어야 합니다
   * @summary 식당 생성
   * @param {ShopCreateRequest} shopCreateRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIApi
   */
  public createShop(
    shopCreateRequest: ShopCreateRequest,
    options?: RawAxiosRequestConfig
  ) {
    return APIApiFp(this.configuration)
      .createShop(shopCreateRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 특정 댓글을 삭제합니다.(Completed)
   * @summary 댓글 삭제
   * @param {number} commentId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIApi
   */
  public deleteComment(commentId: number, options?: RawAxiosRequestConfig) {
    return APIApiFp(this.configuration)
      .deleteComment(commentId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 맛집 탐험 파티 게시글을 삭제합니다.(Completed)
   * @summary 파티 삭제
   * @param {number} partyId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIApi
   */
  public deleteParty(partyId: number, options?: RawAxiosRequestConfig) {
    return APIApiFp(this.configuration)
      .deleteParty(partyId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 프로필 수정 작업 중 예외 발생으로 업로드된 이미지를 삭제합니다.(Completed)
   * @summary 프로필 이미지 삭제
   * @param {DeleteProfileRequest} deleteProfileRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIApi
   */
  public deleteProfile(
    deleteProfileRequest: DeleteProfileRequest,
    options?: RawAxiosRequestConfig
  ) {
    return APIApiFp(this.configuration)
      .deleteProfile(deleteProfileRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 특정 리뷰를 삭제합니다.(Completed)
   * @summary 리뷰 삭제
   * @param {number} reviewId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIApi
   */
  public deleteReview(reviewId: number, options?: RawAxiosRequestConfig) {
    return APIApiFp(this.configuration)
      .deleteReview(reviewId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 회원 탈퇴 기능(Inprogress)
   * @summary 회원탈퇴
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIApi
   */
  public deleteUser(options?: RawAxiosRequestConfig) {
    return APIApiFp(this.configuration)
      .deleteUser(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 문의글 전체를 조회합니다. (Completed)
   * @summary 고객센터의 문의글 전체 조회
   * @param {number} [cursor]
   * @param {number} [size]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIApi
   */
  public getAllInquiry(
    cursor?: number,
    size?: number,
    options?: RawAxiosRequestConfig
  ) {
    return APIApiFp(this.configuration)
      .getAllInquiry(cursor, size, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 특정 모임의 댓글 목록을 조회합니다.(Completed)
   * @summary 댓글 조회
   * @param {number} partyId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIApi
   */
  public getComments(partyId: number, options?: RawAxiosRequestConfig) {
    return APIApiFp(this.configuration)
      .getComments(partyId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 사용자가 특정 식당의 상세 정보를 조회합니다. 식당 등록 상태가 APPROVED인 식당들만 조회 가능 (Completed)
   * @summary 식당 상세 조회
   * @param {number} shopId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIApi
   */
  public getDetailShop(shopId: number, options?: RawAxiosRequestConfig) {
    return APIApiFp(this.configuration)
      .getDetailShop(shopId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 자신이 가진 식당의 상세 정보를 조회합니다. (Completed)
   * @summary 사장의 식당 상세 조회
   * @param {number} shopId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIApi
   */
  public getDetailShopOwner(shopId: number, options?: RawAxiosRequestConfig) {
    return APIApiFp(this.configuration)
      .getDetailShopOwner(shopId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 특정 모임의 댓글 목록을 조회합니다.(Completed)
   * @summary 고객센터 댓글 조회
   * @param {number} inquiryId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIApi
   */
  public getInquiryComments(
    inquiryId: number,
    options?: RawAxiosRequestConfig
  ) {
    return APIApiFp(this.configuration)
      .getInquiryComments(inquiryId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 로그인한 사용자의 마이페이지 정보를 조회합니다.(Completed)
   * @summary 내 정보 조회
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIApi
   */
  public getMyInfo(options?: RawAxiosRequestConfig) {
    return APIApiFp(this.configuration)
      .getMyInfo(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 로그인한 사용자의 파티 목록을 커서 기반 페이징 방식으로 조회합니다.(Completed)
   * @summary 내 파티 정보 조회
   * @param {number} [size]
   * @param {number} [cursor]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIApi
   */
  public getMyParties(
    size?: number,
    cursor?: number,
    options?: RawAxiosRequestConfig
  ) {
    return APIApiFp(this.configuration)
      .getMyParties(size, cursor, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 로그인한 사용자의 예약 목록을 커서 기반 페이징 방식으로 조회합니다.(Completed)
   * @summary 내 예약 정보 조회
   * @param {number} [size]
   * @param {number} [cursor]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIApi
   */
  public getMyReservations(
    size?: number,
    cursor?: number,
    options?: RawAxiosRequestConfig
  ) {
    return APIApiFp(this.configuration)
      .getMyReservations(size, cursor, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 로그인한 사용자가 작성한 리뷰 목록을 커서 기반 페이징 방식으로 조회합니다.(Completed)
   * @summary 내 리뷰 정보 조회
   * @param {number} [size]
   * @param {number} [cursor]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIApi
   */
  public getMyReviews(
    size?: number,
    cursor?: number,
    options?: RawAxiosRequestConfig
  ) {
    return APIApiFp(this.configuration)
      .getMyReviews(size, cursor, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 본인이 작성한 경우이거나 관리자의 경우에만 조회가 가능합니다. (Completed)
   * @summary 자신이 작성한 고객센터의 문의글 하나 상세 조회
   * @param {number} inquiryId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIApi
   */
  public getOneInquiry(inquiryId: number, options?: RawAxiosRequestConfig) {
    return APIApiFp(this.configuration)
      .getOneInquiry(inquiryId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 사장 한명이 가진 식당들 리스트들을 조회합니다. 승인 여부 상태와 상관없이 조회 (Completed)
   * @summary 사장이 가진 식당들 조회
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIApi
   */
  public getOwnerShops(options?: RawAxiosRequestConfig) {
    return APIApiFp(this.configuration)
      .getOwnerShops(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 파티 상태, 위치, 음식 카테고리로 필터링한 파티 게시글 목록을 조회합니다. (Completed)  예시 /parties?status=RECRUITING&minAge=10&categories=CHICKEN&categories=JAPANESE  | 필드 명     | 자료형    | 필수 여부  | 설명                                            | 기본값                   | |------------|---------|-----------|-------------------------------------------------|------------------------| | status     | string  | Optional  | 파티 상태                                        | 전체                    | | gender     | string  | Optional  | 모집 성별 조건(A일 시 성별 무관인 파티만 조회합니다.)   |  전체                   | | minAge     | int     | Optional  | 모집 최소 나이                                    | 전체                    | | maxAge     | int     | Optional  | 모집 최대 나이                                    | 전체                    | | location   | string  | Optional  | 시/도 단위 파티 위치                               | 전체                    | | category   | string  | Optional  | 음식 카테고리 (다중 선택 가능)                       | 전체                    | | query      | string  | Optional  | 파티 제목 검색 키워드                               | 전체                    | | cursor       | int  | Optional   | 페이징 마지막 파티 id                               | 첫번째 페이지            |
   * @summary 파티 목록 조회
   * @param {GetPartiesStatusEnum} [status]
   * @param {GetPartiesGenderEnum} [gender]
   * @param {number} [minAge]
   * @param {number} [maxAge]
   * @param {string} [location]
   * @param {Array<GetPartiesCategoriesEnum>} [categories]
   * @param {string} [query]
   * @param {number} [cursor]
   * @param {number} [size]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIApi
   */
  public getParties(
    status?: GetPartiesStatusEnum,
    gender?: GetPartiesGenderEnum,
    minAge?: number,
    maxAge?: number,
    location?: string,
    categories?: Array<GetPartiesCategoriesEnum>,
    query?: string,
    cursor?: number,
    size?: number,
    options?: RawAxiosRequestConfig
  ) {
    return APIApiFp(this.configuration)
      .getParties(
        status,
        gender,
        minAge,
        maxAge,
        location,
        categories,
        query,
        cursor,
        size,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 맛집 탐험 파티 상세 정보를 조회합니다.(Completed)
   * @summary 파티 상세 조회
   * @param {number} partyId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIApi
   */
  public getPartyDetail(partyId: number, options?: RawAxiosRequestConfig) {
    return APIApiFp(this.configuration)
      .getPartyDetail(partyId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 맛집 탐험 파티원 목록을 조회합니다.(Completed)
   * @summary 파티원 목록 조회
   * @param {number} partyId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIApi
   */
  public getPartyMembers(partyId: number, options?: RawAxiosRequestConfig) {
    return APIApiFp(this.configuration)
      .getPartyMembers(partyId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 결제 내역을 스크롤 방식으로 조회합니다. 사용자의 마이페이지 란에서 조회 가능합니다. (Completed)
   * @summary 결제 내역 조회 api
   * @param {number} [size]
   * @param {number} [cursor]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIApi
   */
  public getPaymentHistories(
    size?: number,
    cursor?: number,
    options?: RawAxiosRequestConfig
  ) {
    return APIApiFp(this.configuration)
      .getPaymentHistories(size, cursor, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * APPROVED(승인) 또는 REJECTED(거절) (Completed)
   * @summary 관리자가 식당 등록에 대한 요청을 승인 또는 거절
   * @param {number} shopId
   * @param {ApproveRequest} approveRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIApi
   */
  public getPendingShop(
    shopId: number,
    approveRequest: ApproveRequest,
    options?: RawAxiosRequestConfig
  ) {
    return APIApiFp(this.configuration)
      .getPendingShop(shopId, approveRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 관리자는 등록을 원하는 식당 리스트를 볼 수 있습니다. (Completed)
   * @summary 관리자가 pending 상태인 식당들 리스트를 가져옴
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIApi
   */
  public getPendingShop1(options?: RawAxiosRequestConfig) {
    return APIApiFp(this.configuration)
      .getPendingShop1(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 내 정보 수정 항목 중 프로필 이미지를 업로드하기 위한 pre-signed url을 생성합니다.(Completed)
   * @summary 프로필 이미지 업로드를 위한 pre-signed url 생성
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIApi
   */
  public getProfilePresignedUrl(options?: RawAxiosRequestConfig) {
    return APIApiFp(this.configuration)
      .getProfilePresignedUrl(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 식당의 예약 목록을 필터와 커서 기반으로 조회한다.(Completed)
   * @summary 식당 예약 목록 조회
   * @param {GetReservationsFilterEnum} [filter]
   * @param {number} [cursor]
   * @param {number} [size]
   * @param {number} [shopId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIApi
   */
  public getReservations(
    filter?: GetReservationsFilterEnum,
    cursor?: number,
    size?: number,
    shopId?: number,
    options?: RawAxiosRequestConfig
  ) {
    return APIApiFp(this.configuration)
      .getReservations(filter, cursor, size, shopId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 특정 가게의 리뷰 목록을 조회합니다.(Completed)
   * @summary 리뷰 조회
   * @param {number} shopId
   * @param {number} [cursor]
   * @param {number} [size]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIApi
   */
  public getReviews(
    shopId: number,
    cursor?: number,
    size?: number,
    options?: RawAxiosRequestConfig
  ) {
    return APIApiFp(this.configuration)
      .getReviews(shopId, cursor, size, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 관리자는 식당에 대한 정보를 볼 수 있습니다. (식당의 등록 상태가 뭐든 볼 수 있음) (Completed)
   * @summary 관리자가 식당에 대한 정보를 봄
   * @param {number} shopId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIApi
   */
  public getShopAdminDetail(shopId: number, options?: RawAxiosRequestConfig) {
    return APIApiFp(this.configuration)
      .getShopAdminDetail(shopId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 일반 사용자가 위치 기반으로 식당 목록을 조회합니다. (식당 상태가 APPROVED인 식당들만 조회 가능) (Completed)  반경은 m 단위로 주시면 되며 ->  3km (3000) 만약 사용자가 자신의 위치를 허용한다면 latitude과 longitude에 사용자 위도 경도, 원하는 범위를 넣어서 요청을 보내고 그렇지 않는다면 기본값으론 종로구 좌표에 3km 범위 식당을 가져옵니다  예시 /shops?radius=1000000&sort=rating  | 필드 명     | 자료형  | 필수 여부 | 설명                   | 기본값           | |------------|---------|-----------|-------------------------|------------------| | latitude   | double  | Required  | 사용자 위치의 위도         | 37.5724          | | longitude  | double  | Required  | 사용자 위치의 경도         | 126.9794         | | radius     | double  | Optional  | 검색 반경 (단위: m)       | 3000.0           | | category   | string  | Optional  | 음식 카테고리             | 전체             | | sort       | string  | Optional  | 정렬 기준 (근처순, 평점순) | 근처 순(distance) |
   * @summary 식당 목록 조회
   * @param {number} [latitude]
   * @param {number} [longitude]
   * @param {number} [radius]
   * @param {Array<GetShopsCategoryEnum>} [category]
   * @param {string} [sort]
   * @param {number} [cursor]
   * @param {number} [size]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIApi
   */
  public getShops(
    latitude?: number,
    longitude?: number,
    radius?: number,
    category?: Array<GetShopsCategoryEnum>,
    sort?: string,
    cursor?: number,
    size?: number,
    options?: RawAxiosRequestConfig
  ) {
    return APIApiFp(this.configuration)
      .getShops(
        latitude,
        longitude,
        radius,
        category,
        sort,
        cursor,
        size,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 키워드로 식당을 검색합니다.정렬기준: NAME, CREATED_AT, RATING  (식당 상태가 APPROVED인 식당들만 조회 가능)(Completed)
   * @summary 식당 검색
   * @param {string} [query]
   * @param {GetShopsBySearchSortEnum} [sort]
   * @param {string} [cursor]
   * @param {number} [size]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIApi
   */
  public getShopsBySearch(
    query?: string,
    sort?: GetShopsBySearchSortEnum,
    cursor?: string,
    size?: number,
    options?: RawAxiosRequestConfig
  ) {
    return APIApiFp(this.configuration)
      .getShopsBySearch(query, sort, cursor, size, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 맛집 탐험 파티를 참여합니다.(Completed)
   * @summary 파티 참여
   * @param {number} partyId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIApi
   */
  public joinParty(partyId: number, options?: RawAxiosRequestConfig) {
    return APIApiFp(this.configuration)
      .joinParty(partyId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 폼 로그인으로 로그인합니다. 성공 시 액세스 토큰은 헤더, 리프레시 토큰은 쿠키에 포함됩니다.(Completed)
   * @summary Form 로그인
   * @param {LoginRequest} loginRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIApi
   */
  public login(loginRequest: LoginRequest, options?: RawAxiosRequestConfig) {
    return APIApiFp(this.configuration)
      .login(loginRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 쿠키의 리프레시 토큰을 무효화하고 로그아웃 처리합니다.
   * @summary 로그아웃
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIApi
   */
  public logout(options?: RawAxiosRequestConfig) {
    return APIApiFp(this.configuration)
      .logout(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  제목과 내용을 작성하여 문의글을 작성합니다   사진 전송 시 헤더에  Cache-Control 값이 no-cache,no-store,must-revalidate 되어 있어야 합니다  (Completed)
   * @summary 고객센터의 문의글 작성
   * @param {InquiryCreateRequest} inquiryCreateRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIApi
   */
  public newInquiry(
    inquiryCreateRequest: InquiryCreateRequest,
    options?: RawAxiosRequestConfig
  ) {
    return APIApiFp(this.configuration)
      .newInquiry(inquiryCreateRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 프론트는 이 URL로 리디렉션하여 OAuth2 로그인을 시작합니다. 예: /oauth2/authorization/google
   * @summary OAuth2 로그인 진입점 URL 안내
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIApi
   */
  public oauth2Urls(options?: RawAxiosRequestConfig) {
    return APIApiFp(this.configuration)
      .oauth2Urls(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * OAuth 추가 회원가입(Completed)
   * @summary 회원가입
   * @param {OAuthSignUpRequest} oAuthSignUpRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIApi
   */
  public oauthSignup(
    oAuthSignUpRequest: OAuthSignUpRequest,
    options?: RawAxiosRequestConfig
  ) {
    return APIApiFp(this.configuration)
      .oauthSignup(oAuthSignUpRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIApi
   */
  public ownerTest(options?: RawAxiosRequestConfig) {
    return APIApiFp(this.configuration)
      .ownerTest(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 맛집 탐험 파티의 예약을 위한 예약금을 지불합니다.(Completed)
   * @summary 파티 예약금 지불
   * @param {number} partyId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIApi
   */
  public payPartyFee(partyId: number, options?: RawAxiosRequestConfig) {
    return APIApiFp(this.configuration)
      .payPartyFee(partyId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 맛집 탐험 파티를 참여를 취소합니다.(Completed)
   * @summary 파티 탈퇴
   * @param {number} partyId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIApi
   */
  public quitParty(partyId: number, options?: RawAxiosRequestConfig) {
    return APIApiFp(this.configuration)
      .quitParty(partyId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 맛집 탐험 파티에서 파티원을 강제 퇴장시킵니다.(Completed)
   * @summary 파티 강퇴
   * @param {number} partyId
   * @param {number} userId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIApi
   */
  public quitParty1(
    partyId: number,
    userId: number,
    options?: RawAxiosRequestConfig
  ) {
    return APIApiFp(this.configuration)
      .quitParty1(partyId, userId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 쿠키의 리프레시 토큰을 이용해 새로운 액세스 토큰을 재발급합니다.
   * @summary 액세스 토큰 재발급
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIApi
   */
  public refreshToken(options?: RawAxiosRequestConfig) {
    return APIApiFp(this.configuration)
      .refreshToken(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * reservationId에 해당하는 예약을 REFUSED 상태로 변경한다. (Completed)
   * @summary 예약 거절
   * @param {number} reservationId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIApi
   */
  public refuseReservation(
    reservationId: number,
    options?: RawAxiosRequestConfig
  ) {
    return APIApiFp(this.configuration)
      .refuseReservation(reservationId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 1. 결제 요청 전에 주문 정보를 서버에 저장    결제하기 버튼을 누를 때 (실제 결제 요청 api 보내기 전) 호출하면 됩니다. orderId는 클라이언트에서 임의의 랜덤한 숫자로 제작합니다. 2. orderId, amount 저장 3. 이후 결제 요청 / 결제 성공 시 서버에 저장된 값과 비교  → 변조 방지, 악의적인 금액 조작 차단  (Completed)
   * @summary 주문 정보 임시 저장 api
   * @param {OrderSaveRequest} orderSaveRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIApi
   */
  public saveOrder(
    orderSaveRequest: OrderSaveRequest,
    options?: RawAxiosRequestConfig
  ) {
    return APIApiFp(this.configuration)
      .saveOrder(orderSaveRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 폼 로그인 회원가입(Completed)
   * @summary 회원가입
   * @param {SignUpRequest} signUpRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIApi
   */
  public signup(signUpRequest: SignUpRequest, options?: RawAxiosRequestConfig) {
    return APIApiFp(this.configuration)
      .signup(signUpRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 로그인한 사용자의 마이페이지 정보를 수정합니다.(Completed)
   * @summary 내 정보 수정
   * @param {MyInfoUpdateRequest} myInfoUpdateRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIApi
   */
  public updateMyInfo(
    myInfoUpdateRequest: MyInfoUpdateRequest,
    options?: RawAxiosRequestConfig
  ) {
    return APIApiFp(this.configuration)
      .updateMyInfo(myInfoUpdateRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 자신이 가진 식당 정보를 수정합니다. (Completed)
   * @summary 사장 식당 정보 수정
   * @param {number} shopId
   * @param {ShopUpdateRequest} shopUpdateRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIApi
   */
  public updateShop(
    shopId: number,
    shopUpdateRequest: ShopUpdateRequest,
    options?: RawAxiosRequestConfig
  ) {
    return APIApiFp(this.configuration)
      .updateShop(shopId, shopUpdateRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIApi
   */
  public userTest(options?: RawAxiosRequestConfig) {
    return APIApiFp(this.configuration)
      .userTest(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * @export
 */
export const GetPartiesStatusEnum = {
  Recruiting: "RECRUITING",
  Completed: "COMPLETED",
  Terminated: "TERMINATED",
} as const;
export type GetPartiesStatusEnum =
  (typeof GetPartiesStatusEnum)[keyof typeof GetPartiesStatusEnum];
/**
 * @export
 */
export const GetPartiesGenderEnum = {
  M: "M",
  W: "W",
  A: "A",
} as const;
export type GetPartiesGenderEnum =
  (typeof GetPartiesGenderEnum)[keyof typeof GetPartiesGenderEnum];
/**
 * @export
 */
export const GetPartiesCategoriesEnum = {
  Chicken: "CHICKEN",
  Chinese: "CHINESE",
  Japanese: "JAPANESE",
  Pizza: "PIZZA",
  Fastfood: "FASTFOOD",
  StewSoup: "STEW_SOUP",
  JokBo: "JOK_BO",
  Korean: "KOREAN",
  Snack: "SNACK",
  Western: "WESTERN",
  Dessert: "DESSERT",
} as const;
export type GetPartiesCategoriesEnum =
  (typeof GetPartiesCategoriesEnum)[keyof typeof GetPartiesCategoriesEnum];
/**
 * @export
 */
export const GetReservationsFilterEnum = {
  Pending: "PENDING",
  Cancelled: "CANCELLED",
  Confirmed: "CONFIRMED",
  Refused: "REFUSED",
  Terminated: "TERMINATED",
} as const;
export type GetReservationsFilterEnum =
  (typeof GetReservationsFilterEnum)[keyof typeof GetReservationsFilterEnum];
/**
 * @export
 */
export const GetShopsCategoryEnum = {
  Chicken: "CHICKEN",
  Chinese: "CHINESE",
  Japanese: "JAPANESE",
  Pizza: "PIZZA",
  Fastfood: "FASTFOOD",
  StewSoup: "STEW_SOUP",
  JokBo: "JOK_BO",
  Korean: "KOREAN",
  Snack: "SNACK",
  Western: "WESTERN",
  Dessert: "DESSERT",
} as const;
export type GetShopsCategoryEnum =
  (typeof GetShopsCategoryEnum)[keyof typeof GetShopsCategoryEnum];
/**
 * @export
 */
export const GetShopsBySearchSortEnum = {
  Rating: "RATING",
  CreatedAt: "CREATED_AT",
  Name: "NAME",
} as const;
export type GetShopsBySearchSortEnum =
  (typeof GetShopsBySearchSortEnum)[keyof typeof GetShopsBySearchSortEnum];

/**
 * ChatControllerApi - axios parameter creator
 * @export
 */
export const ChatControllerApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {number} partyId
     * @param {number} cursor
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loadChatHistory: async (
      partyId: number,
      cursor: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'partyId' is not null or undefined
      assertParamExists("loadChatHistory", "partyId", partyId);
      // verify required parameter 'cursor' is not null or undefined
      assertParamExists("loadChatHistory", "cursor", cursor);
      const localVarPath = `/parties/{partyId}/chat/load`.replace(
        `{${"partyId"}}`,
        encodeURIComponent(String(partyId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication accessToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication refreshToken required

      if (cursor !== undefined) {
        localVarQueryParameter["cursor"] = cursor;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} partyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    restoreChat: async (
      partyId: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'partyId' is not null or undefined
      assertParamExists("restoreChat", "partyId", partyId);
      const localVarPath = `/parties/{partyId}/chat/restore`.replace(
        `{${"partyId"}}`,
        encodeURIComponent(String(partyId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication accessToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication refreshToken required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ChatControllerApi - functional programming interface
 * @export
 */
export const ChatControllerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ChatControllerApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {number} partyId
     * @param {number} cursor
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async loadChatHistory(
      partyId: number,
      cursor: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<BaseResponseChatMessagePageResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.loadChatHistory(
        partyId,
        cursor,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ChatControllerApi.loadChatHistory"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {number} partyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async restoreChat(
      partyId: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<BaseResponseListChatMessageResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.restoreChat(
        partyId,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ChatControllerApi.restoreChat"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ChatControllerApi - factory interface
 * @export
 */
export const ChatControllerApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ChatControllerApiFp(configuration);
  return {
    /**
     *
     * @param {number} partyId
     * @param {number} cursor
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loadChatHistory(
      partyId: number,
      cursor: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponseChatMessagePageResponse> {
      return localVarFp
        .loadChatHistory(partyId, cursor, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {number} partyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    restoreChat(
      partyId: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponseListChatMessageResponse> {
      return localVarFp
        .restoreChat(partyId, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ChatControllerApi - object-oriented interface
 * @export
 * @class ChatControllerApi
 * @extends {BaseAPI}
 */
export class ChatControllerApi extends BaseAPI {
  /**
   *
   * @param {number} partyId
   * @param {number} cursor
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChatControllerApi
   */
  public loadChatHistory(
    partyId: number,
    cursor: number,
    options?: RawAxiosRequestConfig
  ) {
    return ChatControllerApiFp(this.configuration)
      .loadChatHistory(partyId, cursor, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} partyId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChatControllerApi
   */
  public restoreChat(partyId: number, options?: RawAxiosRequestConfig) {
    return ChatControllerApiFp(this.configuration)
      .restoreChat(partyId, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
